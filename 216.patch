From ecb6d7c59755bd952e460c857b50c3155246898d Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Thu, 3 Oct 2024 17:01:11 +0200
Subject: [PATCH 01/11] Silencing GCC compiler warnings

---
 H/globals.h               |  4 ++++
 Makefile-Linux-GCC-64.mak |  8 ++++----
 assemble.c                |  2 +-
 codegenv2.c               |  8 +++++---
 data.c                    |  1 +
 dbgcv.c                   | 10 ++++++----
 expreval.c                |  6 +++---
 hll.c                     |  4 ++--
 invoke.c                  |  7 ++++---
 listing.c                 |  2 +-
 macho64.c                 |  2 +-
 macro.c                   |  2 +-
 option.c                  |  2 ++
 preproc.c                 | 36 ++++++++++++++++++------------------
 reswords.c                |  4 ++--
 simd.c                    |  1 +
 symbols.c                 |  4 ++--
 tokenize.c                | 36 ++++++++++++++++++------------------
 types.c                   |  2 ++
 19 files changed, 78 insertions(+), 63 deletions(-)

diff --git a/H/globals.h b/H/globals.h
index 223d0155..2f6310bf 100644
--- a/H/globals.h
+++ b/H/globals.h
@@ -922,6 +922,10 @@ extern uint_8                MacroLevel;    /* macro nesting level */
 extern bool                  write_to_file; /* 1=write the object module */
 extern bool                  gmaskflag;
 
+#if defined(__UNIX__)
+extern char *strupr(char *);
+#endif
+
 /* functions in assemble.c */
 
 struct fixup;
diff --git a/Makefile-Linux-GCC-64.mak b/Makefile-Linux-GCC-64.mak
index 9d4431a3..a0858520 100644
--- a/Makefile-Linux-GCC-64.mak
+++ b/Makefile-Linux-GCC-64.mak
@@ -12,7 +12,7 @@ inc_dirs  = -IH
 #cflags stuff
 
 ifeq ($(DEBUG),0)
-extra_c_flags = -DNDEBUG -O2 -funsigned-char -Wwrite-strings
+extra_c_flags = -DNDEBUG -O2 -funsigned-char -Werror=write-strings -Wno-discarded-qualifiers
 OUTD=GccUnixR
 else
 extra_c_flags = -DDEBUG_OUT -g
@@ -55,6 +55,6 @@ $(OUTD)/reswords.o: reswords.c H/instruct.h H/special.h H/directve.h H/opndcls.h
 ######
 
 clean:
-	rm $(OUTD)/$(TARGET1)
-	rm $(OUTD)/*.o
-	rm $(OUTD)/*.map
+	rm -f $(OUTD)/$(TARGET1)
+	rm -f $(OUTD)/*.o
+	rm -f $(OUTD)/*.map
diff --git a/assemble.c b/assemble.c
index a9f28992..fa3a67e4 100644
--- a/assemble.c
+++ b/assemble.c
@@ -1798,7 +1798,7 @@ int EXPQUAL AssembleModule( const char *source )
 						printf("%u errors\n", ModuleInfo.g.error_count);
 						SetConsoleTextAttribute(hConsole, screenBufferInfo.wAttributes);
 			#else
-						printf(FWHT("%s: %lu lines, "), GetFNamePart(GetFName(ModuleInfo.srcfile)->fname), GetLineNumber());
+						printf(FWHT("%s: %u lines, "), GetFNamePart(GetFName(ModuleInfo.srcfile)->fname), GetLineNumber());
 						printf(FGRN("%u passes"), Parse_Pass + 1);
 						printf(", ");
 						printf(FCYN("%u ms"), endtime - starttime);
diff --git a/codegenv2.c b/codegenv2.c
index 6bcc08d6..166da2ea 100644
--- a/codegenv2.c
+++ b/codegenv2.c
@@ -1,8 +1,10 @@
 
 #include "codegenv2.h"
 
+#include <ctype.h>
 #include <time.h>
 #include "globals.h"
+#include "input.h"
 #include "parser.h"
 #include "segment.h"
 #include "extern.h"
@@ -34,8 +36,8 @@ struct Instr_Def* InstrHash[16384];
 static unsigned int hash(const uint_8* data, int size)
 /******************************************/
 {
-	uint_64 fnv_basis = 14695981039346656037;
-	uint_64 register fnv_prime = 1099511628211;
+	uint_64 fnv_basis = 14695981039346656037u;
+	uint_64 register fnv_prime = 1099511628211u;
 	uint_64 h = fnv_basis;
 	int cnt = 0;
 	for (cnt = 0; cnt < size; cnt++) {
@@ -863,7 +865,7 @@ void BuildEVEX(bool* needEvex, unsigned char* evexBytes, struct Instr_Def* instr
 
 	 BYTE1:
 	 | 7 | 6 | 5 | 4  | 3 | 2 | 1-0 |
-	 | R | X | B | R’ | 0 | 0 |  m  |
+	 | R | X | B | Rï¿½ | 0 | 0 |  m  |
 
 	BYTE2:
 	 | 7 | 6-3      | 2 | 1-0 |
diff --git a/data.c b/data.c
index 33b981b2..4337cf83 100644
--- a/data.c
+++ b/data.c
@@ -86,6 +86,7 @@ extern ret_code segm_override( const struct expr *, struct code_info * );
 extern struct asym *SegOverride;
 extern const char szNull[];
 extern UINT_PTR UTF8toWideChar(const unsigned char *pSource, UINT_PTR nSourceLen, UINT_PTR *nSourceDone, unsigned short *szTarget, UINT_PTR nTargetMax);
+extern void OutputInterleavedBytes(const unsigned char *pbytes, int len, struct fixup *fixup);
 static ret_code data_item( int *, struct asm_tok[], struct asym *, uint_32, const struct asym *, uint_32, bool inside_struct, bool, bool, int );
 
 #define OutputDataBytes( x, y ) OutputBytes( x, y, NULL )
diff --git a/dbgcv.c b/dbgcv.c
index d702f3d0..988c296c 100644
--- a/dbgcv.c
+++ b/dbgcv.c
@@ -1261,7 +1261,7 @@ static uint_8* cv_FlushSection(dbgcv* cv, uint_32 signature, uint_32 ex)
 #define USEMD5
 
 #ifdef USEMD5
-#define BUFSIZ 1024*4
+#define MD5_BUFSIZ 1024*4
 #define MD5_LENGTH ( sizeof( uint_32 ) + sizeof( uint_16 ) + 16 + sizeof( uint_16 ) )
 
 static int calc_md5(const char* filename, unsigned char* sum)
@@ -1273,10 +1273,10 @@ static int calc_md5(const char* filename, unsigned char* sum)
 
 	if ((fp = fopen(filename, "rb")) == NULL)
 		return 0;
-	file_buf = MemAlloc(BUFSIZ);
+	file_buf = MemAlloc(MD5_BUFSIZ);
 	_picohash_md5_init(&ctx);
 	while (!feof(fp)) {
-		i = fread(file_buf, 1, BUFSIZ, fp);
+		i = fread(file_buf, 1, MD5_BUFSIZ, fp);
 		if (ferror(fp)) {
 			fclose(fp);
 			MemFree(file_buf);
@@ -1353,7 +1353,9 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 		}
 
 		cv.currdir = LclAlloc(_MAX_PATH * 4);
-		_getcwd(cv.currdir, _MAX_PATH * 4);
+		if (!_getcwd(cv.currdir, _MAX_PATH * 4)) {
+			strcpy(cv.currdir, ".");
+		}
 		objname = cv.currdir + strlen(cv.currdir);
 
 		/* source filename string table */
diff --git a/expreval.c b/expreval.c
index 5b8456c6..4240f163 100644
--- a/expreval.c
+++ b/expreval.c
@@ -884,7 +884,7 @@ static ret_code get_operand( struct expr *opnd, int *idx, struct asm_tok tokenar
 			{
 				(*idx)++;
 				strcpy(clabel, tokenarray[(*idx)].string_ptr);
-				sprintf(tokenarray[(*idx)].string_ptr, "%s%s", ".", &clabel);
+				sprintf(tokenarray[(*idx)].string_ptr, "%s%s", ".", clabel);
 			}
 			else if (labelsym == NULL && labelsym2 == NULL)
 			{
@@ -4080,7 +4080,7 @@ static ret_code evaluate( struct expr *opnd1, int *i, struct asm_tok tokenarray[
 		{
 			(*i)++;
 			strcpy(clabel, tokenarray[(*i)].string_ptr);
-			sprintf(tokenarray[(*i)].string_ptr, "%s%s", ".", &clabel);
+			sprintf(tokenarray[(*i)].string_ptr, "%s%s", ".", clabel);
 		}
 		else if (labelsym == NULL && labelsym2 == NULL)
 		{
@@ -4104,7 +4104,7 @@ static ret_code evaluate( struct expr *opnd1, int *i, struct asm_tok tokenarray[
 		{
 			//(*i)++;
 			strcpy(clabel, tokenarray[(*i)+2].string_ptr);
-			sprintf(tokenarray[(*i)+2].string_ptr, "%s%s", ".", &clabel);
+			sprintf(tokenarray[(*i)+2].string_ptr, "%s%s", ".", clabel);
 			tokenarray[(*i) + 1].string_ptr = tokenarray[(*i) + 2].string_ptr;
 			tokenarray[(*i) + 1].token = T_ID;
 			tokenarray[(*i) + 2].token = T_FINAL;
diff --git a/hll.c b/hll.c
index 0492410e..d5bb4f1f 100644
--- a/hll.c
+++ b/hll.c
@@ -2095,9 +2095,9 @@ ret_code HllEndDir(int i, struct asm_tok tokenarray[])
                             dcnt = 0;                          /* reset data caunter */
                         }
                         if (dcnt)
-                            sprintf(unum, ",%d", hll->pcases64[j]);
+                            sprintf(unum, ",%lu", hll->pcases64[j]);
                         else
-                            sprintf(unum, "%d", hll->pcases64[j]);
+                            sprintf(unum, "%lu", hll->pcases64[j]);
                         strcat(buffer, unum);
                         dcnt++;
                         j++;
diff --git a/invoke.c b/invoke.c
index 750bd643..cca71497 100644
--- a/invoke.c
+++ b/invoke.c
@@ -22,6 +22,7 @@
 #include "listing.h"
 #include "myassert.h"
 #include "label.h"
+#include "fixup.h"
 #include "hll.h"
 
 #include "segment.h"
@@ -3145,7 +3146,7 @@ static int ParamIsString(char *pStr, int param, struct dsym* proc) {
 			if (p->sym.target_type)
 			{
 				type = p->sym.target_type;
-				while (type->target_type && (int)type->target_type > 0x2000)
+				while (type->target_type && (unsigned long)type->target_type > 0x2000)
 				{
 					type = type->target_type;
 					if (type->mem_type == MT_PTR)
@@ -3192,8 +3193,8 @@ static int ParamIsString(char *pStr, int param, struct dsym* proc) {
 static unsigned int hashpjw(const char *s)
 /******************************************/
 {
-	uint_64 fnv_basis = 14695981039346656037;
-	uint_64 register fnv_prime = 1099511628211;
+	uint_64 fnv_basis = 14695981039346656037u;
+	uint_64 register fnv_prime = 1099511628211u;
 	uint_64 h;
 	for (h = fnv_basis; *s; ++s) {
 		h ^= (*s | ' ');
diff --git a/listing.c b/listing.c
index e27f2a55..3aa4c30c 100644
--- a/listing.c
+++ b/listing.c
@@ -123,7 +123,7 @@ static const struct print_item cr[] = {
 
 struct lstleft {
     struct lstleft *next;
-    char buffer[4*8];
+    char buffer[4*8 + 1];
     char last;
 };
 
diff --git a/macho64.c b/macho64.c
index 8e74842b..8b81d5ee 100644
--- a/macho64.c
+++ b/macho64.c
@@ -725,7 +725,7 @@ static ret_code macho_write_module( struct module_info *modinfo )
 		mm.header.cputype = CPU_TYPE_X86_64;
 		mm.header.cpusubtype = CPU_SUBTYPE_LITTLE_ENDIAN | CPU_SUBTYPE_X86_64_ALL;
 		mm.header.filetype = MH_OBJECT;
-		mm.header.flags = NULL;
+		mm.header.flags = 0;
 		
 		macho_build_structures(modinfo, mm);	
 	}
diff --git a/macro.c b/macro.c
index 43c71ead..bcdd6e44 100644
--- a/macro.c
+++ b/macro.c
@@ -48,7 +48,7 @@
 
 extern int  MacroLocals;
 
-extern bool inMacroBody = FALSE;
+bool inMacroBody = FALSE;
 
 /* the list of macro param + local names is hold temporarily only.
  * once the names have been replaced by placeholders,
diff --git a/option.c b/option.c
index 7e21ff0d..8ea48032 100644
--- a/option.c
+++ b/option.c
@@ -33,6 +33,8 @@ extern struct asym          *sym_Interface;
 #define OPTFUNC( name ) extern ret_code OPTQUAL name( int *pi, struct asm_tok tokenarray[] )
 extern void UpdateStackBase( struct asym *, void * );
 extern void UpdateProcStatus( struct asym *, void * );
+extern void CreateMacroLibCases32( void );
+extern void CreateMacroLibCases64( void );
 
 static struct asym *AddPredefinedConstant(const char *name, int value)
 /**********************************************************************/
diff --git a/preproc.c b/preproc.c
index ef8ad1de..e4a0ab26 100644
--- a/preproc.c
+++ b/preproc.c
@@ -582,7 +582,7 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 		/* Transfer new source line back for token rescan */
 		if (didExpand)
 		{
-			strcpy(line, &newline);
+			strcpy(line, newline);
 			Token_Count = Tokenize(line, 0, tokenarray, TOK_RESCAN);
 		}
 	}
@@ -777,7 +777,7 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 	int clIdx, opIdx;
 	int tokenCount;
 	struct asm_tok *tokenarray2;
-	char *p = &newline;
+	char *p = newline;
 	char idxStack[] = { 0, 0, 0, 0 };
 	int stackPt = -1;
 	char idxline[MAX_LINE_LEN];
@@ -786,7 +786,7 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 	bool expandedCall = FALSE;
 	char uCnt = 0;
 
-	strcpy(&newline, line);
+	strcpy(newline, line);
 	memset(&idxline, 0, MAX_LINE_LEN);
 
 	for (i = 0;i < Token_Count;i++)
@@ -964,7 +964,7 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 				}
 
 				/* Reset string pointer*/
-				p = &newline;			
+				p = newline;
 			}
 		}
 	}
@@ -979,7 +979,7 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 	//finally replace place-holder with idxline value
 	if (expandedCall)
 	{
-		p = &newline;
+		p = newline;
 		p = strstr(p, "invoke"); // even if the line only contains uinvoke, such as in an HLL expression this will still find it.
 		if (p != NULL)
 		{
@@ -999,7 +999,7 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 				p++;
 			}
 		}
-		p = &newline;
+		p = newline;
 		p = strstr(p, "arginvoke(");
 		j = (int)(p - (char *)&newline);
 		while (p)
@@ -1015,11 +1015,11 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 		}
 
 		/* Ensure max nesting depth isn't exceeded */
-		VerifyNesting(&newline, hasExprBracket);
+		VerifyNesting(newline, hasExprBracket);
 	}
 
 	/* Transfer new source line back for token rescan */
-	strcpy(line, &newline);
+	strcpy(line, newline);
 }
 
 static bool PossibleCallExpansion(struct asm_tok tokenarray[])
@@ -1128,23 +1128,23 @@ int PreprocessLine( char *line, struct asm_tok tokenarray[] )
 		// Hll and Object style call expansion is only valid inside a code section, AND if the line contains ( ) or ->.
 		if (CurrSeg && (strcmp(CurrSeg->sym.name, "_TEXT") == 0 || strcmp(CurrSeg->sym.name, "_flat") == 0) && PossibleCallExpansion( tokenarray ))
 		{
-			strcpy(&cline, line);
-			ExpandStaticObjCalls(&cline, tokenarray);
-			if (strcmp(&cline, line) != 0)
+			strcpy(cline, line);
+			ExpandStaticObjCalls(cline, tokenarray);
+			if (strcmp(cline, line) != 0)
 			{
-				strcpy(line, &cline);
+				strcpy(line, cline);
 				Token_Count = Tokenize(line, 0, tokenarray, TOK_RESCAN);
 			}
-			ExpandObjCalls(&cline, tokenarray);
-			if (strcmp(&cline, line) != 0)
+			ExpandObjCalls(cline, tokenarray);
+			if (strcmp(cline, line) != 0)
 			{
-				strcpy(line, &cline);
+				strcpy(line, cline);
 				Token_Count = Tokenize(line, 0, tokenarray, TOK_RESCAN);
 			}
-			ExpandHllCalls(&cline, tokenarray, FALSE, 0, FALSE);
-			if (strcmp(&cline, line) != 0)
+			ExpandHllCalls(cline, tokenarray, FALSE, 0, FALSE);
+			if (strcmp(cline, line) != 0)
 			{
-				strcpy(line, &cline);
+				strcpy(line, cline);
 				Token_Count = Tokenize(line, 0, tokenarray, TOK_RESCAN);
 			}
 		}
diff --git a/reswords.c b/reswords.c
index 03273f96..54429c07 100644
--- a/reswords.c
+++ b/reswords.c
@@ -970,8 +970,8 @@ static bool  b64bit = FALSE; /* resw tables in 64bit mode? */
 static unsigned get_hash(const char *s, unsigned char size)
 /***********************************************************/
 {
-  uint_64 fnv_basis = 14695981039346656037;
-  uint_64 register fnv_prime = 1099511628211;
+  uint_64 fnv_basis = 14695981039346656037u;
+  uint_64 register fnv_prime = 1099511628211u;
   uint_64 h;
   for (h = fnv_basis; size; size--) {
 	  h ^= (*s++ | ' ');
diff --git a/simd.c b/simd.c
index 8a414762..728de0c1 100644
--- a/simd.c
+++ b/simd.c
@@ -10,6 +10,7 @@ and their sub-types
 #include "simd.h"
 #include "globals.h"
 #include "symbols.h"
+#include "lqueue.h"
 
 extern void     AddLineQueue(const char *line);
 extern void     AddLineQueueX(const char *fmt, ...);
diff --git a/symbols.c b/symbols.c
index 1b28fa80..7c272149 100644
--- a/symbols.c
+++ b/symbols.c
@@ -155,8 +155,8 @@ static bool structLookup = FALSE;
 static unsigned int hashpjw( const char *s )
 /******************************************/
 {
-	uint_64 fnv_basis = 14695981039346656037;
-	uint_64 register fnv_prime = 1099511628211;
+	uint_64 fnv_basis = 14695981039346656037u;
+	uint_64 register fnv_prime = 1099511628211u;
 	uint_64 h;
 	for (h = fnv_basis; *s; ++s) {
 		h ^= (*s | ' ');
diff --git a/tokenize.c b/tokenize.c
index cb71c117..c5128c4d 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -1167,14 +1167,14 @@ static ret_code get_id( struct asm_tok *buf, struct line_status *p )
  * varname.abc -> . is an operator
  */
 
-#define is_valid_id_start( ch )  ( islalpha(ch) || ch=='_' || ch=='@' || ch=='$' || ch=='?' )
+#define GetToken_is_valid_id_start( ch )  ( islalpha(ch) || ch=='_' || ch=='@' || ch=='$' || ch=='?' )
 
 ret_code GetToken( struct asm_tok token[], struct line_status *p )
 /****************************************************************/
 {
     if( isldigit( *p->input ) ) {
         return( get_number( token, p ) );
-    } else if( is_valid_id_start( *p->input ) ) {
+    } else if( GetToken_is_valid_id_start( *p->input ) ) {
         return( get_id( token, p ) );
     } else if( *p->input == '.' &&
 #if DOTNAMEX /* allow dots within identifiers */
@@ -1231,7 +1231,7 @@ int Tokenize( char *line, unsigned int start, struct asm_tok tokenarray[], unsig
     p.flags = flags;
     p.flags2 = 0;
     p.flags3 = 0;
-    char* buff[256];
+    char buff[256];
     if ( p.index == 0 ) 
 	{
 #ifdef DEBUG_OUT
@@ -1333,28 +1333,28 @@ int Tokenize( char *line, unsigned int start, struct asm_tok tokenarray[], unsig
                 ;//OK QWORD
               else
                 goto nobcst;                       /* let parser throw error */
-              if (*input1 != '\[') {               /* if address is not inside [] */
-                *p1++ = '\[';                      /* force it   */
+              if (*input1 != '[') {                /* if address is not inside [] */
+                *p1++ = '[';                       /* force it   */
                 for (; *input1 > ','; p1++, input1++) {  /* input1 points to [address] */
                   if (*input1 == ';') 
                     break;
                   *p1 = *input1;                     /* copy first memory part over 'qword bcst */
                 }
-                *p1++ = '\]';
+                *p1++ = ']';
                 if (*input1 == ';')
                   *input1 = 0;
                 while (isspace(*input1)) input1++;   /* skip the space, now pointing to address  */
               }
               else {
-                for (; *input1 != '\]'; p1++, input1++) /* input1 points to [address] */
+                for (; *input1 != ']'; p1++, input1++) /* input1 points to [address] */
                   *p1 = *input1;                     /* copy first memory part over 'qword bcst */
                 *p1++ = *input1++;                   /* copy ']' */
               }
               /* now add broadcast size */
-              if (cnt == 2)       strcpy(p1, "\{1to2\}");
-              else if (cnt == 4)  strcpy(p1, "\{1to4\}");
-              else if (cnt == 8)  strcpy(p1, "\{1to8\}");
-              else if (cnt == 16) strcpy(p1, "\{1to16\}");
+              if (cnt == 2)       strcpy(p1, "{1to2}");
+              else if (cnt == 4)  strcpy(p1, "{1to4}");
+              else if (cnt == 8)  strcpy(p1, "{1to8}");
+              else if (cnt == 16) strcpy(p1, "{1to16}");
               else goto nobcst;                   /* let parser throw error */
               strcat(p1, input1);
             }
@@ -1364,24 +1364,24 @@ int Tokenize( char *line, unsigned int start, struct asm_tok tokenarray[], unsig
                 if (*p1 == ';') {                        /* found  ';' */
                   *p1 = 0;                             /* that means '{' is in comment */
                 }
-                if (*p1 == '\{') {                     /* found  '{' */
-                  if ((_memicmp(p1, "\{1to", 4) == 0))
+                if (*p1 == '{') {                      /* found  '{' */
+                  if ((_memicmp(p1, "{1to", 4) == 0))
                     break;                             /* found "bcst" */
                 }                                      /* if it was {kn} or {z} search till end */
               }
-              if (*p1 == '\{') {                       /* if found {1toN} */
+              if (*p1 == '{') {                        /* if found {1toN} */
                 p1--;                                  /* go back 1 byte to check if ']' is present */
                 while (isspace(*p1)) --p1;             /* skip the space  */
-                if (*p1 != '\]') {                     /* if not present insert it  */
+                if (*p1 != ']') {                      /* if not present insert it  */
                   while (*p1 != ',') --p1;             /* step backwards till the comma */
                   p1++;                                /* skip the comma forward  */
                   input1 = p1;                         /* save that location in input1  */
                   while (isspace(*p1)) p1++;           /* skip the space  */
                   strcpy(buff, p1);                    /* copy to the buffer from variable on  */
-                  *input1++ = '\[';                    /* skip the space  */
-                  for (p1 = buff; *p1 != '\{'; p1++, input1++) /* till the end of var  */
+                  *input1++ = '[';                     /* skip the space  */
+                  for (p1 = buff; *p1 != '{'; p1++, input1++) /* till the end of var  */
                     *input1 = *p1;                      /* copy it back to input string  */
-                  *input1++ = '\]';                    /* insert ']' before '{' */
+                  *input1++ = ']';                     /* insert ']' before '{' */
                   strcpy(input1, p1);                  /* now copy the rest of string from buffer */
                 }
               }
diff --git a/types.c b/types.c
index d6076a35..8bdc4963 100644
--- a/types.c
+++ b/types.c
@@ -24,6 +24,8 @@
 #include "fastpass.h"
 #include "myassert.h"
 
+extern void SymSimd(struct dsym *);
+
 /* v2.04: changed to 0 */
 //#define ANYNAME 1 /* fixme: this probably should be changed to 0 */
 #define ANYNAME 0

From 055e46a67298aa1b764dc8979e28cdddcb07cd15 Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Wed, 9 Oct 2024 00:20:13 +0200
Subject: [PATCH 02/11] make code build in GCC 14 and Clang 18

---
 codegenv2.c |  6 +++---
 dbgcv.c     |  2 +-
 expreval.c  |  2 +-
 input.c     |  4 ++--
 invoke.c    | 19 ++++++++++---------
 macho64.c   |  6 +++---
 omf.c       |  2 +-
 preproc.c   | 41 +++++++++++++++++++++--------------------
 proc.c      | 28 ++++++++++++++--------------
 9 files changed, 56 insertions(+), 54 deletions(-)

diff --git a/codegenv2.c b/codegenv2.c
index 166da2ea..36e3710a 100644
--- a/codegenv2.c
+++ b/codegenv2.c
@@ -90,7 +90,7 @@ uint_32 GenerateInstrHash(struct Instr_Def* pInstruction)
 	*(pDst + 4) = pInstruction->operand_types[4];
 	len += 4;
 	pDst += 4;
-	return hash(&hashBuffer, len);
+	return hash(hashBuffer, len);
 }
 
 void BuildInstructionTable(void)
@@ -1703,7 +1703,7 @@ ret_code CodeGenV2(const char* instr, struct code_info* CodeInfo, uint_32 oldofs
 		/* If the matched instruction requires processing of a memory address */
 		if (matchedInstr->memOpnd != NO_MEM)
 			aso = BuildMemoryEncoding(&modRM, &sib, &rexByte, &needModRM, &needSIB,								/* This could result in modifications to REX/VEX/EVEX, modRM and SIB bytes */
-				&dispSize, &displacement, matchedInstr, opExpr, &needB, &needX, &needRR, CodeInfo);
+				&dispSize, &displacement.displacement64, matchedInstr, opExpr, &needB, &needX, &needRR, CodeInfo);
 		modRM |= BuildModRM(matchedInstr->modRM, matchedInstr, opExpr, &needModRM, &needSIB,
 			((matchedInstr->vexflags & VEX) || (matchedInstr->vexflags & EVEX)));								/* Modify the modRM value for any non-memory operands */
 
@@ -1711,7 +1711,7 @@ ret_code CodeGenV2(const char* instr, struct code_info* CodeInfo, uint_32 oldofs
 		   Create REX, VEX or EVEX prefixes                      
 		  ----------------------------------------------------------*/
 		if ((matchedInstr->vexflags & VEX) != 0 && (matchedInstr->evexflags & EVEX_ONLY) == 0 && CodeInfo->evex_flag == 0)
-			BuildVEX(&needVEX, &vexSize, &vexBytes, matchedInstr, opExpr, needB, needX, opCount);				/* Create the VEX prefix bytes for both reg and memory operands */
+			BuildVEX(&needVEX, &vexSize, vexBytes, matchedInstr, opExpr, needB, needX, opCount);				/* Create the VEX prefix bytes for both reg and memory operands */
 
 		  /* Either the instruction can ONLY be EVEX encoded, or user requested VEX->EVEX promotion. */
 		else if ((matchedInstr->evexflags & EVEX_ONLY) != 0 ||
diff --git a/dbgcv.c b/dbgcv.c
index 988c296c..0fb1aeb8 100644
--- a/dbgcv.c
+++ b/dbgcv.c
@@ -1254,7 +1254,7 @@ static uint_8* cv_FlushSection(dbgcv* cv, uint_32 signature, uint_32 ex)
 	seg->e.seginfo->current_loc = seg->e.seginfo->start_loc + currsize + ex + sizeof(CV_SECTION);
 	seg->e.seginfo->start_loc = seg->e.seginfo->current_loc;
 
-	return(cv->section);
+	return((uint_8*)cv->section);
 }
 
 
diff --git a/expreval.c b/expreval.c
index 4240f163..c8112978 100644
--- a/expreval.c
+++ b/expreval.c
@@ -4144,7 +4144,7 @@ static ret_code evaluate( struct expr *opnd1, int *i, struct asm_tok tokenarray[
 				{
 					if (opnd1->type != NULL)
 					{
-						recordsym = SymSearch(opnd1->type->name);
+						recordsym = (struct dsym *)SymSearch(opnd1->type->name);
 						/* if it is a RECORD don't throw an error but decorate it with an actual value v2.41*/
 						if (recordsym && recordsym->sym.typekind == TYPE_RECORD)
 						{
diff --git a/input.c b/input.c
index b92720cb..afe0460a 100644
--- a/input.c
+++ b/input.c
@@ -206,7 +206,7 @@ static unsigned AddFile( char const *fname )
             memcpy( newfn, ModuleInfo.g.FNames, index * sizeof( struct fname_item ) );
             MemFree( ModuleInfo.g.FNames );
         }
-        ModuleInfo.g.FNames = newfn;
+        ModuleInfo.g.FNames = (char **)newfn;
     }
     ModuleInfo.g.cnt_fnames++;
 
@@ -218,7 +218,7 @@ static unsigned AddFile( char const *fname )
 const struct fname_item *GetFName( unsigned index )
 /*************************************************/
 {
-    return( ModuleInfo.g.FNames+index );
+    return( (struct fname_item *)(ModuleInfo.g.FNames+index) );
 }
 
 /* free the file array.
diff --git a/invoke.c b/invoke.c
index cca71497..80eeb420 100644
--- a/invoke.c
+++ b/invoke.c
@@ -3239,7 +3239,8 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 	struct dsym *currs;
 	size_t slen;
 	char *pSrc;
-	char *pDest;
+	uint_16 *pDest;
+	uint_8 *pDest2;
 	char *labelstr = "__ls";
 	char buf[32];
 	char c1;
@@ -3287,7 +3288,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 
 				lbl = SymLookup(buf);
 				SetSymSegOfs(lbl);
-				memset(&buff, 0, 256);
+				memset(&buff, 0, 256*sizeof(uint_16));
 				pDest = buff;
 				finallen = slen;
 
@@ -3362,7 +3363,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 				lbl = SymLookup(buf);
 				memset(&buff, 0, 256);
 
-				pDest = buff2;
+				pDest2 = buff2;
 				finallen = slen;
 
 				while (*pSrc != '"')
@@ -3371,28 +3372,28 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 					c2 = *(pSrc);
 					if (c1 == '\\' && c2 == 'n')
 					{
-						*pDest++ = 10;
+						*pDest2++ = 10;
 						finallen--;
 						pSrc++;
 					}
 					else if (c1 == '\\' && c2 == 'r')
 					{
-						*pDest++ = 13;
+						*pDest2++ = 13;
 						finallen--;
 						pSrc++;
 					}
 					else if (c1 == '\\' && c2 == 't')
 					{
-						*pDest++ = 9;
+						*pDest2++ = 9;
 						finallen--;
 						pSrc++;
 					}
 					else
-						*pDest++ = c1;
+						*pDest2++ = c1;
 				}
-				*pDest++ = 0;
+				*pDest2++ = 0;
 
-				j = UTF8toWideChar(&buff2, slen, NULL, (unsigned short *)&buff, slen);
+				j = UTF8toWideChar(buff2, slen, NULL, buff, slen);
 				/* j contains a proper number of wide chars, it can be different than slen, v2.38 */
 				SetSymSegOfs(lbl);
 				OutputBytes((unsigned char *)&buff, (j * 2) + 2, NULL);
diff --git a/macho64.c b/macho64.c
index 8b81d5ee..906c96c3 100644
--- a/macho64.c
+++ b/macho64.c
@@ -44,7 +44,7 @@ struct macho_section_entry
 {
 	char *srcName;
 	struct section_64 section;
-	struct section_64 *next;
+	struct macho_section_entry *next;
 	int dif; /* padding to keep section size multiple of 16 */
 	int size;
 	int ofs;
@@ -280,7 +280,7 @@ static int GetSymbolIndex(const char *pName, struct macho_module *mm)
 /* ==========================================================================================
 Build a macho_section_entry structure.
 ========================================================================================== */
-struct section_64 * macho_build_section( const char *secName, const char *segName, uint32_t flags, const char *srcName )
+struct macho_section_entry * macho_build_section( const char *secName, const char *segName, uint32_t flags, const char *srcName )
 {
 	struct macho_section_entry *pSec = NULL;
 	pSec = malloc(sizeof(struct macho_section_entry));
@@ -308,7 +308,7 @@ static void macho_add_section(struct macho_section_entry *pSec, struct macho_mod
 	{
 		while (pCurrSec->next != NULL)
 		{
-			pCurrSec = pCurrSec->next;
+			pCurrSec = (struct macho_section_entry *)pCurrSec->next;
 		}
 		pCurrSec->next = pSec;
 	}
diff --git a/omf.c b/omf.c
index 18d4a602..fe804643 100644
--- a/omf.c
+++ b/omf.c
@@ -1284,7 +1284,7 @@ static ret_code omf_write_autodep( void )
     unsigned        idx;
 
     DebugMsg(("omf_write_autodep() enter\n"));
-    for( idx = 0, curr = ModuleInfo.g.FNames; idx < ModuleInfo.g.cnt_fnames; idx++, curr++ ) {
+    for( idx = 0, curr = (struct fname_item *)ModuleInfo.g.FNames; idx < ModuleInfo.g.cnt_fnames; idx++, curr++ ) {
         omf_InitRec( &obj, CMD_COMENT );
         obj.d.coment.attr = CMT_TNP;
         obj.d.coment.cmt_class = CMT_DEPENDENCY; /* 0xE9 */
diff --git a/preproc.c b/preproc.c
index e4a0ab26..56600572 100644
--- a/preproc.c
+++ b/preproc.c
@@ -193,7 +193,7 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 				{
 					for (j = i - 1; j >= 0; j--)
 					{
-						tsym = SymCheck(tokenarray[j].string_ptr);
+						tsym = (struct dsym *)SymCheck(tokenarray[j].string_ptr);
 						if (tokenarray[j].token == T_DIRECTIVE && (tokenarray[j].dirtype == DRT_HLLSTART || tokenarray[j].dirtype == DRT_HLLEND))
 						{
 							inExpr = TRUE;
@@ -239,26 +239,26 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 				{
 					if (derefCount == 0)
 					{
-						sym = SymCheck(tokenarray[i - 1].string_ptr);
+						sym = (struct dsym *)SymCheck(tokenarray[i - 1].string_ptr);
 						if (sym && sym->sym.target_type && sym->sym.target_type > 0x200000 && sym->sym.target_type->isClass)
 						{
 							foundType = TRUE;
 							pType = tokenarray[i - 1].string_ptr;
-							type = sym->sym.target_type;
+							type = (struct dsym *)sym->sym.target_type;
 							firstDeRefIdx = i - 2; /* pointer->item */
 						}
 						else if (sym && sym->sym.type && sym->sym.type->target_type && sym->sym.type->target_type > 0x200000 && sym->sym.type->target_type->isClass)
 						{
 							foundType = TRUE;
 							pType = tokenarray[i - 1].string_ptr;
-							type = sym->sym.type->target_type;
+							type = (struct dsym *)sym->sym.type->target_type;
 							firstDeRefIdx = i - 2; /* pointer->item */
 						}
 						else if (sym && sym->sym.type && sym->sym.type->target_type && sym->sym.type->target_type > 0x200000 && sym->sym.type->target_type->isPtrTable)
 						{
 							foundType = TRUE;
 							pType = tokenarray[i - 1].string_ptr;
-							type = sym->sym.type->target_type;
+							type = (struct dsym *)sym->sym.type->target_type;
 							firstDeRefIdx = 0; /* pointer->item */
 						}
 						/* Indirect register using .TYPE */
@@ -315,9 +315,9 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 						}
 						if (gotField)
 						{
-							type = field->sym.target_type;
+							type = (struct dsym *)field->sym.target_type;
 							if (!type || type < 0x10)
-								type = field->sym.type->target_type;
+								type = (struct dsym *)field->sym.type->target_type;
 							if (!type || type < 0x10)
 								EmitError(INVALID_POINTER);
 						}
@@ -335,12 +335,12 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 				/* Direct register object reference */
 				else if (tokenarray[i - 1].token == T_REG)
 				{
-					sym = StdAssumeTable[GetRegNo(tokenarray[i - 1].tokval)].symbol;
+					sym = (struct dsym *)StdAssumeTable[GetRegNo(tokenarray[i - 1].tokval)].symbol;
 					if (sym && sym->sym.target_type)
 					{
 						foundType = TRUE;
 						pType = tokenarray[i - 1].string_ptr;
-						type = sym->sym.target_type;
+						type = (struct dsym *)sym->sym.target_type;
 						firstDeRefIdx = i - 2; /* pointer->item */
 					}
 					else
@@ -366,11 +366,11 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 						EmitError(INVALID_POINTER);
 					// The tokens between opSqIdx and clSqIdx make up the indirect address.
 					// -> the first register(base) must be assumed to an object pointer.
-					sym = StdAssumeTable[GetRegNo(tokenarray[opSqIdx + 1].tokval)].symbol;
+					sym = (struct dsym *)StdAssumeTable[GetRegNo(tokenarray[opSqIdx + 1].tokval)].symbol;
 					if (sym && sym->sym.target_type)
 					{
 						foundType = TRUE;
-						pType = &indirectAddr;
+						pType = indirectAddr;
 						pType = strcpy(pType, "[") + 1;
 						for (j = opSqIdx + 1; j < clSqIdx; j++)
 						{
@@ -378,8 +378,8 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 							pType += strlen(tokenarray[j].string_ptr);
 						}
 						pType = strcpy(pType, "]") + 1;
-						pType = &indirectAddr;
-						type = sym->sym.target_type;
+						pType = indirectAddr;
+						type = (struct dsym *)sym->sym.target_type;
 						firstDeRefIdx = opSqIdx-1; /* pointer->item */
 					}
 					else
@@ -391,16 +391,16 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 					EmitError(INVALID_POINTER);
 				else
 				{
-					pMethodStr = &methodName;
+					pMethodStr = methodName;
 					pMethodStr = strcpy(pMethodStr, "_") + 1;
 					strcpy(pMethodStr, type->sym.name);
 					pMethodStr += strlen(type->sym.name);
 					pMethodStr = strcpy(pMethodStr, "_") + 1;
 					strcpy(pMethodStr, tokenarray[i + 1].string_ptr);
 					pMethodStr += strlen(tokenarray[i + 1].string_ptr);
-					pMethodStr = &methodName;
+					pMethodStr = methodName;
 
-					sym = SymCheck(pMethodStr);
+					sym = (struct dsym *)SymCheck(pMethodStr);
 					if (sym && sym->sym.isproc)
 					{
 						foundProc = TRUE;
@@ -626,7 +626,7 @@ static void ExpandStaticObjCalls(char *line, struct asm_tok tokenarray[])
 					{
 						for (j = i - 1; j >= 0; j--)
 						{
-							tsym = SymCheck(tokenarray[j].string_ptr);
+							tsym = (struct dsym *)SymCheck(tokenarray[j].string_ptr);
 							if (tokenarray[j].token == T_DIRECTIVE && (tokenarray[j].dirtype == DRT_HLLSTART || tokenarray[j].dirtype == DRT_HLLEND))
 							{
 								inExpr = TRUE;
@@ -772,6 +772,7 @@ static struct asym * TraverseEquate(struct asym *sym)
 static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam, int argIdx, bool inExpr)
 {
 	int i, j;
+	struct asym *asym;
 	struct dsym *sym;
 	char newline[MAX_LINE_LEN];
 	int clIdx, opIdx;
@@ -793,9 +794,9 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 	{
 		if (tokenarray[i].token == T_ID)
 		{
-			sym = SymCheck(tokenarray[i].string_ptr);
+			asym = SymCheck(tokenarray[i].string_ptr);
 
-			sym = TraverseEquate(sym); /* We may have an equate chain that points to a proc, as we expand here before macro substitution we need to consider this */
+			sym = (struct dsym *)TraverseEquate(asym); /* We may have an equate chain that points to a proc, as we expand here before macro substitution we need to consider this */
 
 			if(sym && (sym->sym.isproc || (sym->sym.isfunc && sym->sym.state == SYM_EXTERNAL)) && tokenarray[i+1].tokval != T_PROC && tokenarray[i+1].tokval != T_PROTO && 
 				tokenarray[i+1].tokval != T_ENDP && tokenarray[i+1].tokval != T_EQU && tokenarray[i+1].token == T_OP_BRACKET) 
@@ -1070,7 +1071,7 @@ void EvaluatePreprocessItems(char *line, struct asm_tok tokenarray[])
 		/* only a token of type ID could possibly be an inline record */
 		if (tokenarray[i].token == T_ID)
 		{
-			recsym = SymCheck(tokenarray[i].string_ptr);
+			recsym = (struct dsym *)SymCheck(tokenarray[i].string_ptr);
 			if (recsym && recsym->sym.typekind == TYPE_RECORD && CurrProc)
 			{
 				if (CurrSeg && (strcmp(CurrSeg->sym.name, "_TEXT") == 0 || strcmp(CurrSeg->sym.name, "_flat") == 0))
diff --git a/proc.c b/proc.c
index a984bb98..f308c52e 100644
--- a/proc.c
+++ b/proc.c
@@ -141,12 +141,12 @@ static const int sysv_maxreg[] = {
 
 
 struct fastcall_conv {
-	int(*paramcheck)(struct dsym *, struct dsym *, int *);
+	int(*paramcheck)(struct dsym *, struct dsym *, int *, int *);
 	void(*handlereturn)(struct dsym *, char *buffer);
 };
 
 struct vectorcall_conv {
-	int(*paramcheck)(struct dsym *, struct dsym *, int *);
+	int(*paramcheck)(struct dsym *, struct dsym *, int *, int *);
 	void(*handlereturn)(struct dsym *, char *buffer);
 };
 
@@ -156,21 +156,21 @@ struct sysvcall_conv {
 };
 
 struct delphicall_conv {
-	int(*paramcheck)(struct dsym *, struct dsym *, int *);
+	int(*paramcheck)(struct dsym *, struct dsym *, int *, int *);
 	void(*handlereturn)(struct dsym *, char *buffer);
 };
 
 
-static  int ms32_pcheck(struct dsym *, struct dsym *, int *);
+static  int ms32_pcheck(struct dsym *, struct dsym *, int *, int *);
 static void ms32_return(struct dsym *, char *);
 
 #if OWFC_SUPPORT
-static  int watc_pcheck(struct dsym *, struct dsym *, int *);
+static  int watc_pcheck(struct dsym *, struct dsym *, int *, int *);
 static void watc_return(struct dsym *, char *);
 #endif
 
 #if AMD64_SUPPORT
-static  int ms64_pcheck(struct dsym *, struct dsym *, int *);
+static  int ms64_pcheck(struct dsym *, struct dsym *, int *, int *);
 static void ms64_return(struct dsym *, char *);
 #endif
 
@@ -180,7 +180,7 @@ static void sysv_return(struct dsym *, char *);
 #endif
 
 #if DELPHI_SUPPORT
-static  int delphi_pcheck(struct dsym *, struct dsym *, int *);
+static  int delphi_pcheck(struct dsym *, struct dsym *, int *, int *);
 static void delphi_return(struct dsym *, char *);
 #endif
 
@@ -294,7 +294,7 @@ static void SetLocalOffsets_RBP_SYSV(struct proc_info* info);
 * will do the cleanup, else the called proc does it.
 * in VARARG procs, all parameters are pushed onto the stack!
 */
-static int watc_pcheck(struct dsym *proc, struct dsym *paranode, int *used)
+static int watc_pcheck(struct dsym *proc, struct dsym *paranode, int *used, int *unused)
 /***************************************************************************/
 {
 	static char regname[64];
@@ -397,7 +397,7 @@ static void watc_return(struct dsym *proc, char *buffer)
 * The 16-bit ABI uses registers AX, DX and BX - additional registers
 * are pushed in PASCAL order (i.o.w.: left to right).
 */
-static int ms32_pcheck(struct dsym *proc, struct dsym *paranode, int *used)
+static int ms32_pcheck(struct dsym *proc, struct dsym *paranode, int *used, int *unused)
 /***************************************************************************/
 {
 	char regname[32];
@@ -445,7 +445,7 @@ static void ms32_return(struct dsym *proc, char *buffer)
 }
 
 /* v2.29: delphi uses 3 register params (EAX,EDX,ECX) */
-static int delphi_pcheck(struct dsym *proc, struct dsym *paranode, int *used)
+static int delphi_pcheck(struct dsym *proc, struct dsym *paranode, int *used, int *unused)
 /***************************************************************************/
 {
 	char regname[32];
@@ -516,7 +516,7 @@ static void delphi_return(struct dsym *proc, char *buffer)
 * [esp+16] for param 2,... The parameter names refer to those stack
 * locations, not to the register names.
 */
-static int ms64_pcheck(struct dsym *proc, struct dsym *paranode, int *used)
+static int ms64_pcheck(struct dsym *proc, struct dsym *paranode, int *used, int *unused)
 /***************************************************************************/
 {
 	/* since the parameter names refer the stack-backup locations,
@@ -1030,16 +1030,16 @@ static ret_code ParseParams(struct dsym *proc, int i, struct asm_tok tokenarray[
 			paranode->sym.is_ptr = ti.is_ptr;
 			paranode->sym.ptr_memtype = ti.ptr_memtype;
 			paranode->sym.is_vararg = is_vararg;
-			if (proc->sym.langtype == LANG_FASTCALL && fastcall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint))
+			if (proc->sym.langtype == LANG_FASTCALL && fastcall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint, NULL))
 			{
 			}
-			else if (proc->sym.langtype == LANG_VECTORCALL && vectorcall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint))
+			else if (proc->sym.langtype == LANG_VECTORCALL && vectorcall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint, NULL))
 			{
 			}
 			else if (proc->sym.langtype == LANG_SYSVCALL && sysvcall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint, &vecint))
 			{
 			}
-			else if (proc->sym.langtype == LANG_DELPHICALL && delphicall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint))
+			else if (proc->sym.langtype == LANG_DELPHICALL && delphicall_tab[ModuleInfo.fctype].paramcheck(proc, paranode, &fcint, NULL))
 			{
 			}
 			else

From ecd4b944924d7d195194eb52b2cf6d127cda920d Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Wed, 9 Oct 2024 03:35:30 +0200
Subject: [PATCH 03/11] -Wmemset-elt-size

---
 invoke.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/invoke.c b/invoke.c
index 80eeb420..cbcc0614 100644
--- a/invoke.c
+++ b/invoke.c
@@ -3361,7 +3361,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 				pSrc = (tokenarray[i + 1].string_ptr) + 1;
 				sprintf(buf, "%s%d", labelstr, hashpjw(pSrc));
 				lbl = SymLookup(buf);
-				memset(&buff, 0, 256);
+				memset(&buff, 0, 256*sizeof(uint_16));
 
 				pDest2 = buff2;
 				finallen = slen;

From 16bf1d51b1fdc3a425e61f886140e151cb9b548f Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Wed, 9 Oct 2024 14:21:23 +0200
Subject: [PATCH 04/11] resolve pointer comparison issues

---
 H/globals.h |  1 +
 H/symbols.h |  2 ++
 assemble.c  |  2 +-
 coff.c      |  8 ++++----
 preproc.c   | 10 +++++-----
 5 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/H/globals.h b/H/globals.h
index 2f6310bf..f0dc2ff4 100644
--- a/H/globals.h
+++ b/H/globals.h
@@ -34,6 +34,7 @@
 
 #define _CRT_DISABLE_PERFCRIT_LOCKS
 
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/H/symbols.h b/H/symbols.h
index 6562c19b..de167da6 100644
--- a/H/symbols.h
+++ b/H/symbols.h
@@ -222,6 +222,7 @@ struct asym {
         uint_32         max_mbr_size; /* max size members */
         /* SYM_STACK, SYM_TYPE (TYPEKIND_TYPEDEF), SYM_EXTERNAL, SYM_INTERNAL (code labels) */
         struct asym     *target_type; /* set if ptr_memtype is MT_TYPE */
+        uintptr_t       target_type_val;
         /* SYM_TMACRO (if it's a register variable for FASTCALL) */
         uint_16         regist[2];
     };
@@ -246,6 +247,7 @@ struct asym {
          * total number of elements (LENGTHOF)
          */
         uint_32        total_length;
+        uintptr_t      altname_val;
         struct asym    *altname;     /* SYM_EXTERNAL (comm==0): alternative name */
         struct debug_info *debuginfo;/* SYM_INTERNAL (isproc==1): debug info (COFF) */
         internal_func  sfunc_ptr;    /* SYM_INTERNAL+predefined */
diff --git a/assemble.c b/assemble.c
index fa3a67e4..aac92fac 100644
--- a/assemble.c
+++ b/assemble.c
@@ -1039,7 +1039,7 @@ static void PassOneChecks( void )
          */
 #if FASTPASS
         /* UASM 2.55 , altname is set to 1 when the type is undefined */
-        if ( curr->sym.altname > 1 ) 
+        if ( curr->sym.altname_val > 1 )
 		{
             if ( curr->sym.altname->state == SYM_INTERNAL ) 
 			{
diff --git a/coff.c b/coff.c
index e421511b..f837e0c0 100644
--- a/coff.c
+++ b/coff.c
@@ -209,8 +209,8 @@ static ret_code coff_write_section_table( struct module_info *modinfo, struct co
                     continue;
                 }
                 /* UASM 2.56 For RIP relative addresses in the same section, we don't want a COFF fixup */
-                else if (fix->sym && curr->e.seginfo->Ofssize == USE64 && curr == fix->sym->segment && fix->type == FIX_RELOFF32 
-                    && fix->sym->isdefined && !fix->sym->isfar && fix->sym->state != SYM_EXTERNAL) {
+                else if (fix->sym && curr->e.seginfo->Ofssize == USE64 && curr == (struct dsym *)(fix->sym->segment)
+                    && fix->type == FIX_RELOFF32 && fix->sym->isdefined && !fix->sym->isfar && fix->sym->state != SYM_EXTERNAL) {
                     uint_32* cp = (uint_32*)(curr->e.seginfo->CodeBuffer + (fix->locofs - curr->e.seginfo->start_loc));
                     uint_32 src = fix->sym->offset - (fix->locofs + fix->addbytes);
                     (*cp) += src;
@@ -892,8 +892,8 @@ static void coff_write_fixups( struct dsym *section, uint_32 *poffset, uint_32 *
         }
 
         /* UASM 2.56 For RIP relative addresses in the same section, we don't want a COFF fixup */
-        if (fix->sym && section->e.seginfo->Ofssize == USE64 && section == fix->sym->segment && fix->type == FIX_RELOFF32 
-            && fix->sym->isdefined && !fix->sym->isfar && fix->sym->state != SYM_EXTERNAL) {
+        if (fix->sym && section->e.seginfo->Ofssize == USE64 && section == (struct dsym *)(fix->sym->segment)
+            && fix->type == FIX_RELOFF32 && fix->sym->isdefined && !fix->sym->isfar && fix->sym->state != SYM_EXTERNAL) {
         }
         else {
             coff_write_fixup(fix->locofs, fix->sym->ext_idx, type);
diff --git a/preproc.c b/preproc.c
index 56600572..9de7d6f0 100644
--- a/preproc.c
+++ b/preproc.c
@@ -240,21 +240,21 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 					if (derefCount == 0)
 					{
 						sym = (struct dsym *)SymCheck(tokenarray[i - 1].string_ptr);
-						if (sym && sym->sym.target_type && sym->sym.target_type > 0x200000 && sym->sym.target_type->isClass)
+						if (sym && sym->sym.target_type && sym->sym.target_type_val > 0x200000 && sym->sym.target_type->isClass)
 						{
 							foundType = TRUE;
 							pType = tokenarray[i - 1].string_ptr;
 							type = (struct dsym *)sym->sym.target_type;
 							firstDeRefIdx = i - 2; /* pointer->item */
 						}
-						else if (sym && sym->sym.type && sym->sym.type->target_type && sym->sym.type->target_type > 0x200000 && sym->sym.type->target_type->isClass)
+						else if (sym && sym->sym.type && sym->sym.type->target_type && sym->sym.type->target_type_val > 0x200000 && sym->sym.type->target_type->isClass)
 						{
 							foundType = TRUE;
 							pType = tokenarray[i - 1].string_ptr;
 							type = (struct dsym *)sym->sym.type->target_type;
 							firstDeRefIdx = i - 2; /* pointer->item */
 						}
-						else if (sym && sym->sym.type && sym->sym.type->target_type && sym->sym.type->target_type > 0x200000 && sym->sym.type->target_type->isPtrTable)
+						else if (sym && sym->sym.type && sym->sym.type->target_type && sym->sym.type->target_type_val > 0x200000 && sym->sym.type->target_type->isPtrTable)
 						{
 							foundType = TRUE;
 							pType = tokenarray[i - 1].string_ptr;
@@ -316,9 +316,9 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 						if (gotField)
 						{
 							type = (struct dsym *)field->sym.target_type;
-							if (!type || type < 0x10)
+							if (!type || field->sym.target_type_val < 0x10)
 								type = (struct dsym *)field->sym.type->target_type;
-							if (!type || type < 0x10)
+							if (!type || field->sym.type->target_type_val < 0x10)
 								EmitError(INVALID_POINTER);
 						}
 						else

From e60a4a35ca03190638f6d091728ded1b3f741ffb Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Sat, 19 Oct 2024 20:15:13 +0200
Subject: [PATCH 05/11] clang warnings -Wparentheses -Wdangling-else
 -Wreturn-type

---
 ...ile-Linux-GCC-64.mak => Makefile-Linux.mak | 18 +++++++---
 Makefile_Linux.mak => Makefile_Linux_Old.mak  |  0
 assemble.c                                    | 30 +++++++++-------
 assume.c                                      |  3 +-
 bin.c                                         | 16 ++++-----
 cmdline.c                                     |  8 ++---
 codegen.c                                     | 17 ++++++----
 coff.c                                        |  6 ++--
 cpumodel.c                                    |  3 +-
 data.c                                        |  8 +++--
 dbgcv.c                                       |  4 +--
 directiv.c                                    |  2 +-
 equate.c                                      |  8 +++--
 expans.c                                      |  5 +--
 expreval.c                                    |  4 +--
 extern.c                                      | 11 +++---
 hll.c                                         |  4 +--
 input.c                                       |  4 +--
 invoke.c                                      | 34 ++++++++++++-------
 label.c                                       |  6 ++--
 macho64.c                                     |  6 ++--
 macro.c                                       | 11 +++---
 omf.c                                         | 12 +++++--
 parser.c                                      | 24 ++++++++-----
 posndir.c                                     |  8 +++--
 preproc.c                                     |  6 ++--
 proc.c                                        | 11 ++++--
 string.c                                      |  4 +--
 symbols.c                                     |  2 +-
 types.c                                       |  4 +--
 30 files changed, 174 insertions(+), 105 deletions(-)
 rename Makefile-Linux-GCC-64.mak => Makefile-Linux.mak (77%)
 rename Makefile_Linux.mak => Makefile_Linux_Old.mak (100%)

diff --git a/Makefile-Linux-GCC-64.mak b/Makefile-Linux.mak
similarity index 77%
rename from Makefile-Linux-GCC-64.mak
rename to Makefile-Linux.mak
index a0858520..07c90143 100644
--- a/Makefile-Linux-GCC-64.mak
+++ b/Makefile-Linux.mak
@@ -6,23 +6,33 @@ TARGET1=uasm
 ifndef DEBUG
 DEBUG=0
 endif
+ifndef CLANG
+CLANG=0
+endif
 
 inc_dirs  = -IH
 
 #cflags stuff
 
 ifeq ($(DEBUG),0)
-extra_c_flags = -DNDEBUG -O2 -funsigned-char -Werror=write-strings -Wno-discarded-qualifiers
+extra_c_flags = -DNDEBUG -O2 -funsigned-char -Werror=write-strings
 OUTD=GccUnixR
 else
 extra_c_flags = -DDEBUG_OUT -g
 OUTD=GccUnixD
 endif
 
-c_flags =-D __UNIX__ $(extra_c_flags)
-
-#From CLANG 11+, default has changed from allowing global variables to be defined in the headers (-fcommon) to not allowing it (-fno-common)."   USE: make CC="clang -fcommon" -f gccLinux64.mak
+ifeq ($(CLANG),0)
 CC = gcc
+extra_c_flags += -Wno-discarded-qualifiers
+else
+CC = clang
+extra_c_flags += -Wno-incompatible-pointer-types-discards-qualifiers
+extra_c_flags += -Wno-pointer-sign -Wno-switch -Wno-enum-conversion -Wno-enum-compare -Wno-comment
+extra_c_flags += -Wno-unsequenced -Wno-pointer-bool-conversion -Wno-deprecated-non-prototype
+endif
+
+c_flags =-D __UNIX__ $(extra_c_flags)
 
 .SUFFIXES:
 .SUFFIXES: .c .o
diff --git a/Makefile_Linux.mak b/Makefile_Linux_Old.mak
similarity index 100%
rename from Makefile_Linux.mak
rename to Makefile_Linux_Old.mak
diff --git a/assemble.c b/assemble.c
index aac92fac..b5807f5b 100644
--- a/assemble.c
+++ b/assemble.c
@@ -688,7 +688,7 @@ static void CmdlParamsInit( int pass )
         add_cmdline_tmacros();
         add_incpaths();
         if ( Options.ignore_include == FALSE )
-            if ( env = getenv( "INCLUDE" ) )
+            if ( (env = getenv( "INCLUDE" )) != NULL )
                 AddStringToIncludePath( env );
     }
     DebugMsg(("CmdlParamsInit exit\n"));
@@ -1203,10 +1203,11 @@ static int OnePass( void )
             DebugMsg1(("OnePass(%u) cur/nxt=%X/%X src=%X.%u mlvl=%u: >%s<\n", Parse_Pass+1, LineStoreCurr, LineStoreCurr->next, LineStoreCurr->srcfile, LineStoreCurr->lineno, MacroLevel, LineStoreCurr->line ));
             ModuleInfo.CurrComment = NULL; /* v2.08: added (var is never reset because GetTextLine() isn't called) */
 #if USELSLINE
-            if ( Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
+            Token_Count = Tokenize( LineStoreCurr->line, 0, ModuleInfo.tokenarray, TOK_DEFAULT );
 #else
-            if ( Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT ) )
+            Token_Count = Tokenize( CurrSource, 0, ModuleInfo.tokenarray, TOK_DEFAULT );
 #endif
+            if ( Token_Count > 0 )
                 ParseLine( ModuleInfo.tokenarray );
             LineStoreCurr = LineStoreCurr->next;
         }
@@ -1414,24 +1415,29 @@ void close_files( void )
 
 /* get default file extension for error, object and listing files */
 
+#if MZ_SUPPORT || PE_SUPPORT
+#if PE_SUPPORT
+#define SUB_FORMAT_IS_MZ_OR_PE  (Options.sub_format == SFORMAT_MZ || Options.sub_format == SFORMAT_PE)
+#else
+#define SUB_FORMAT_IS_MZ_OR_PE  (Options.sub_format == SFORMAT_MZ)
+#endif
+#endif
+
 static char *GetExt( int type )
 /*****************************/
 {
     switch ( type ) {
     case OBJ:
 #if BIN_SUPPORT
-        if ( Options.output_format == OFORMAT_BIN )
-#if MZ_SUPPORT || PE_SUPPORT
-            if ( Options.sub_format == SFORMAT_MZ
-#if PE_SUPPORT
-                || Options.sub_format == SFORMAT_PE
-#endif
-               )
+        if ( Options.output_format == OFORMAT_BIN ) {
+#ifdef SUB_FORMAT_IS_MZ_OR_PE
+            if ( SUB_FORMAT_IS_MZ_OR_PE ) {
                 return( EXE_EXT );
-            else
+            }
 #endif
-                return( BIN_EXT );
+            return( BIN_EXT );
 #endif
+        }
         return( OBJ_EXT );
     case LST:
         return( LST_EXT );
diff --git a/assume.c b/assume.c
index c7d2b7c7..0d442ae8 100644
--- a/assume.c
+++ b/assume.c
@@ -255,11 +255,12 @@ void ModelAssumeInit( void )
 struct asym *GetStdAssume( int reg )
 /**********************************/
 {
-    if ( StdAssumeTable[reg].symbol )
+    if ( StdAssumeTable[reg].symbol ) {
         if ( StdAssumeTable[reg].symbol->mem_type == MT_TYPE )
             return( StdAssumeTable[reg].symbol->type );
         else
             return( StdAssumeTable[reg].symbol->target_type );
+    }
     return ( NULL );
 }
 
diff --git a/bin.c b/bin.c
index d40b0a66..e246de9d 100644
--- a/bin.c
+++ b/bin.c
@@ -477,7 +477,7 @@ static ret_code DoFixup( struct dsym *curr, struct calc_param *cp )
                 /* check if symbol's segment name contains a '$'.
                  * If yes, search the segment without suffix.
                  */
-                if ( tmp = strchr( seg->sym.name, '$' ) ) {
+                if ( (tmp = strchr( seg->sym.name, '$' )) != NULL ) {
                     int namlen = tmp - seg->sym.name;
                     struct dsym *segfirst;
                     for( segfirst = SymTables[TAB_SEG].head; segfirst; segfirst = segfirst->next ) {
@@ -1011,7 +1011,7 @@ static void pe_emit_import_data( void )
             }
 
             /* avoid . in IDs */
-            if ( pdot = strchr( p->name, '.') )
+            if ( (pdot = strchr( p->name, '.')) != NULL )
                 *pdot = '_';
 
             /* import directory entry */
@@ -1432,13 +1432,13 @@ static void pe_set_values( struct calc_param *cp )
 #endif
 
     /* set export directory data dir value */
-    if ( curr = (struct dsym *)SymSearch( edataname ) ) {
+    if ( (curr = (struct dsym *)SymSearch( edataname )) != NULL ) {
         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = curr->e.seginfo->start_offset;
         datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = curr->sym.max_offset;
     }
 
     /* set import directory and IAT data dir value */
-    if ( curr = (struct dsym *)SymSearch( ".idata$" IMPDIRSUF ) ) {
+    if ( (curr = (struct dsym *)SymSearch( ".idata$" IMPDIRSUF )) != NULL ) {
         struct dsym *idata_null;
         struct dsym *idata_iat;
         uint_32 size;
@@ -1452,13 +1452,13 @@ static void pe_set_values( struct calc_param *cp )
     }
 
     /* set resource directory data dir value */
-    if ( curr = (struct dsym *)SymSearch(".rsrc") ) {
+    if ( (curr = (struct dsym *)SymSearch(".rsrc")) != NULL ) {
         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = curr->e.seginfo->start_offset;
         datadir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = curr->sym.max_offset;
     }
 
     /* set relocation data dir value */
-    if ( curr = (struct dsym *)SymSearch(".reloc") ) {
+    if ( (curr = (struct dsym *)SymSearch(".reloc")) != NULL ) {
         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = curr->e.seginfo->start_offset;
         datadir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = curr->sym.max_offset;
     }
@@ -1466,14 +1466,14 @@ static void pe_set_values( struct calc_param *cp )
     /* fixme: TLS entry is not written because there exists a segment .tls, but
      * because a _tls_used symbol is found ( type: IMAGE_THREAD_DIRECTORY )
      */
-    if ( curr = (struct dsym *)SymSearch(".tls") ) {
+    if ( (curr = (struct dsym *)SymSearch(".tls")) != NULL ) {
         datadir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = curr->e.seginfo->start_offset;
         datadir[IMAGE_DIRECTORY_ENTRY_TLS].Size = curr->sym.max_offset;
     }
 
 #if AMD64_SUPPORT
     if ( ModuleInfo.defOfssize == USE64 ) {
-        if ( curr = (struct dsym *)SymSearch( ".pdata" ) ) {
+        if ( (curr = (struct dsym *)SymSearch( ".pdata" )) != NULL ) {
             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress = curr->e.seginfo->start_offset;
             datadir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size = curr->sym.max_offset;
         }
diff --git a/cmdline.c b/cmdline.c
index 34e5094d..2da0f463 100644
--- a/cmdline.c
+++ b/cmdline.c
@@ -828,6 +828,7 @@ static char *ReadParamFile( const char *name )
     FILE        *file;
     int         len;
     char        ch;
+    size_t      nread;
 
     DebugMsg(("ReadParamFile(%s) enter\n"));
     env = NULL;
@@ -843,11 +844,8 @@ static char *ReadParamFile( const char *name )
         len = ftell( file );
         rewind( file );
         env = MemAlloc( len + 1 );
-#if defined(__GNUC__) /* gcc warns if return value of fread() is "ignored" */
-        if ( fread( env, 1, len, file ) );
-#else
-        fread( env, 1, len, file );
-#endif
+        nread = fread( env, 1, len, file );
+        (void)nread;
         env[len] = NULLC;
     }
     fclose( file );
diff --git a/codegen.c b/codegen.c
index 3edf3a16..d4d57f80 100644
--- a/codegen.c
+++ b/codegen.c
@@ -758,8 +758,8 @@ static void output_opc(struct code_info *CodeInfo)
             else{
               /* These instructions if, not 0x62, can be only 0xC5, Uasm 2.16 */
                 if (CodeInfo->token == T_VPMOVMSKB){
-                  if(ins->byte1_info == F_0F && (CodeInfo->prefix.rex & REX_B == 0)&& 
-                     (CodeInfo->prefix.rex & REX_X == 0) && (CodeInfo->prefix.rex & REX_W == 8))
+                  if(ins->byte1_info == F_0F && ((CodeInfo->prefix.rex & REX_B) == 0) && 
+                     ((CodeInfo->prefix.rex & REX_X) == 0) && ((CodeInfo->prefix.rex & REX_W) == 8))
                         goto outC5;    // go handle 0xC5 instruction
                   //CodeInfo->prefix.rex &= ~REX_W; // clear the W bit.
                   if(CodeInfo->reg3 > 7) lbyte |= 1;
@@ -895,7 +895,7 @@ static void output_opc(struct code_info *CodeInfo)
                 if ((CodeInfo->reg2 <= 7) || (CodeInfo->reg2 >= 16 && CodeInfo->reg2 <= 23))
                   byte1 |= EVEX_P0RMASK;
                 else byte1 &= ~EVEX_P0RMASK;
-                if (CodeInfo->opnd[OPND1].type & OP_M_ANY == 0){
+                if ((CodeInfo->opnd[OPND1].type & OP_M_ANY) == 0){
                   if (CodeInfo->reg1 <= 15) byte1 |= EVEX_P0XMASK;
                   else byte1 &= ~EVEX_P0XMASK;
                   if ((CodeInfo->reg1 <= 7) || (CodeInfo->reg1 >= 16 && CodeInfo->reg1 <= 23))
@@ -1469,9 +1469,11 @@ static void output_opc(struct code_info *CodeInfo)
                     //else if (CodeInfo->mem_type == MT_YMMWORD && CodeInfo->r1type == OP_YMM);//that is good
                     //else if (CodeInfo->mem_type == MT_ZMMWORD && CodeInfo->r1type == OP_ZMM);//that is good
                     //else  goto error1;
-                      if (CodeInfo->indextype == OP_XMM || CodeInfo->indextype == OP_YMM) 
-                         if (CodeInfo->r2type != OP_XMM) goto error1;
-                      else if (CodeInfo->r2type == OP_YMM && CodeInfo->indextype != OP_ZMM) goto error1;
+                      if (CodeInfo->indextype == OP_XMM || CodeInfo->indextype == OP_YMM) {
+                        if (CodeInfo->r2type != OP_XMM) goto error1;
+                      } else if (CodeInfo->r2type == OP_YMM && CodeInfo->indextype != OP_ZMM) {
+                        goto error1;
+                      }
                       if (CodeInfo->indextype == OP_YMM) CodeInfo->evex_p2 |= EVEX_P2LMASK;
                       else if (CodeInfo->indextype == OP_ZMM){
                         CodeInfo->evex_p2 &= ~EVEX_P2LMASK;    /* Clear first EVEX_P2LMASK because it was set before */
@@ -3181,11 +3183,12 @@ static ret_code match_phase_3( struct code_info *CodeInfo, enum operand_type opn
             if ( CodeInfo->opnd[OPND2].InsFixup != NULL && CodeInfo->opnd[OPND2].InsFixup->sym && CodeInfo->opnd[OPND2].InsFixup->sym->state != SYM_UNDEFINED ) /* external? then skip */
                 break;
 
-            if ( CodeInfo->const_size_fixed == FALSE )
+            if ( CodeInfo->const_size_fixed == FALSE ) {
                 if ( ( opnd1 & ( OP_R16 | OP_M16 ) ) && (int_8)CodeInfo->opnd[OPND2].data32l == (int_16)CodeInfo->opnd[OPND2].data32l )
                     tbl_op2 |= OP_I16;
                 else if ( ( opnd1 & ( OP_RGT16 | OP_MGT16 ) ) && (int_8)CodeInfo->opnd[OPND2].data32l == (int_32)CodeInfo->opnd[OPND2].data32l )
                     tbl_op2 |= OP_I32;
+            }
 
             if( opnd2 & tbl_op2 ) {
                 DebugMsg1(("match_phase_3: matched OP_I8\n"));
diff --git a/coff.c b/coff.c
index f837e0c0..f1350df4 100644
--- a/coff.c
+++ b/coff.c
@@ -1067,7 +1067,8 @@ static void coff_create_drectve( struct module_info *modinfo, struct coffmod *cm
      */
     if ( modinfo->g.start_label != NULL || modinfo->g.LibQueue.head != NULL ||
         imp != NULL || exp != NULL ) {
-        if ( cm->directives = (struct dsym *)CreateIntSegment( szdrectve, "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {
+        cm->directives = (struct dsym *)CreateIntSegment( szdrectve, "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE );
+        if ( cm->directives ) {
             struct dsym *tmp;
             int size = 0;
             struct qitem *q;
@@ -1224,7 +1225,8 @@ static ret_code coff_write_module( struct module_info *modinfo )
     if ( modinfo->g.SafeSEHQueue.head ) {
         struct qnode *sehp;
         unsigned cnt = 0;
-        if ( cm.sxdata = (struct dsym *)CreateIntSegment( ".sxdata", "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE ) ) {
+        cm.sxdata = (struct dsym *)CreateIntSegment( ".sxdata", "", MAX_SEGALIGNMENT, modinfo->Ofssize, FALSE );
+        if ( cm.sxdata ) {
             cm.sxdata->e.seginfo->info = TRUE;
             /* calc the size for this segment */
             for( sehp = modinfo->g.SafeSEHQueue.head; sehp ; sehp = sehp->next, cnt++ );
diff --git a/cpumodel.c b/cpumodel.c
index c090e1ee..a8139bf4 100644
--- a/cpumodel.c
+++ b/cpumodel.c
@@ -425,13 +425,14 @@ ret_code SetCPU( enum cpu_info newcpu )
 
     DebugMsg1(("SetCPU: ModuleInfo.curr_cpu=%X, @Cpu=%X\n", ModuleInfo.curr_cpu, ModuleInfo.cpu ));
 
-    if ( ModuleInfo.model == MODEL_NONE )
+    if ( ModuleInfo.model == MODEL_NONE ) {
 #if AMD64_SUPPORT
         if ( ( ModuleInfo.curr_cpu & P_CPU_MASK) >= P_64 ) {
             SetDefaultOfssize( USE64 );
         } else
 #endif
             SetDefaultOfssize( ((ModuleInfo.curr_cpu & P_CPU_MASK) >= P_386) ? USE32 : USE16 );
+    }
 
     /* Set @Cpu */
     /* differs from Codeinfo cpu setting */
diff --git a/data.c b/data.c
index 4337cf83..d7fbbbfe 100644
--- a/data.c
+++ b/data.c
@@ -418,8 +418,7 @@ static ret_code InitStructuredVar( int index, struct asm_tok tokenarray[], const
             break;
 
         if ( f->next != NULL ) {
-
-            if ( tokenarray[i].token != T_FINAL )
+            if ( tokenarray[i].token != T_FINAL ) {
                 if ( tokenarray[i].token == T_COMMA )
                     i++;
                 else {
@@ -427,6 +426,7 @@ static ret_code InitStructuredVar( int index, struct asm_tok tokenarray[], const
                     while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )
                         i++;
                 }
+            }
         }
     }  /* end for */
 
@@ -1381,7 +1381,9 @@ ret_code data_dir( int i, struct asm_tok tokenarray[], struct asym *type_sym )
                 return ( ERROR );
             }
 #if FASTPASS
-            if ( StoreState ) FStoreLine(0);
+            if ( StoreState ) {
+                FStoreLine(0) {}
+            }
 #endif
             currofs = sym->offset;
             sym->isdata = TRUE; /* 'first_size' is valid */
diff --git a/dbgcv.c b/dbgcv.c
index 0fb1aeb8..a2760500 100644
--- a/dbgcv.c
+++ b/dbgcv.c
@@ -1686,7 +1686,7 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 	/* scan symbol table for types */
 
 	sym = NULL;
-	while (sym = SymEnum(sym, &i)) {
+	while ( (sym = SymEnum(sym, &i)) != NULL ) {
 		if (sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF && sym->cvtyperef == 0)
 			cv_write_type(&cv, sym);
 	}
@@ -1694,7 +1694,7 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 	/* scan symbol table for SYM_TYPE, SYM_INTERNAL */
 
 	sym = NULL;
-	while (sym = SymEnum(sym, &i)) {
+	while ( (sym = SymEnum(sym, &i)) != NULL ) {
 		switch (sym->state) {
 		case SYM_TYPE: /* may create an S_UDT entry in the symbols table */
 			if (Options.debug_ext < CVEX_NORMAL) /* v2.10: no UDTs for -Zi0 and -Zi1 */
diff --git a/directiv.c b/directiv.c
index 3e742fb0..e2ab5ed8 100644
--- a/directiv.c
+++ b/directiv.c
@@ -260,7 +260,7 @@ ret_code IncBinDirective( int i, struct asm_tok tokenarray[] )
     DebugMsg1(("IncBinDirective: filename=%s, offset=%" I32_SPEC "u, size=%" I32_SPEC "u\n", StringBufferEnd, fileoffset, sizemax ));
 
     /* try to open the file */
-    if ( file = SearchFile( StringBufferEnd, FALSE ) ) 
+    if ( (file = SearchFile( StringBufferEnd, FALSE )) != NULL ) 
 	{
 		/* v2.14 : Get File Size */
 		fseek( file, 0L, SEEK_END );
diff --git a/equate.c b/equate.c
index fc281cbc..fbdc6908 100644
--- a/equate.c
+++ b/equate.c
@@ -176,7 +176,9 @@ static struct asym *CreateAssemblyTimeVariable( struct asm_tok tokenarray[] )
              */
             if( opnd.sym && opnd.sym->state == SYM_UNDEFINED && opnd.indirect == FALSE ) {
 #if FASTPASS
-                if ( StoreState == FALSE ) FStoreLine(0); /* make sure this line is evaluated in pass two */
+                if ( StoreState == FALSE ) {
+                    FStoreLine(0) {} /* make sure this line is evaluated in pass two */
+                }
 #endif
             } else
                 EmitError( CONSTANT_EXPECTED );
@@ -269,7 +271,7 @@ ret_code EqualSgnDirective( int i, struct asm_tok tokenarray[] )
     if( tokenarray[0].token != T_ID ) {
         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
     }
-    if ( sym = CreateAssemblyTimeVariable( tokenarray ) ) {
+    if ( (sym = CreateAssemblyTimeVariable( tokenarray )) != NULL ) {
         if ( ModuleInfo.list == TRUE ) {
             LstWrite( LSTTYPE_EQUATE, 0, sym );
         }
@@ -555,7 +557,7 @@ ret_code EquDirective( int i, struct asm_tok tokenarray[] )
         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[0].string_ptr ) );
     }
     DebugMsg1(("EquDirective(%s): calling CreateConstant\n", tokenarray[0].string_ptr ));
-    if ( sym = CreateConstant( tokenarray ) ) {
+    if ( (sym = CreateConstant( tokenarray )) != NULL ) {
         /**/myassert( sym->state == SYM_INTERNAL ); /* must not be a text macro */
         if ( ModuleInfo.list == TRUE ) {
             LstWrite( LSTTYPE_EQUATE, 0, sym );
diff --git a/expans.c b/expans.c
index 24ef7a89..915a6b23 100644
--- a/expans.c
+++ b/expans.c
@@ -353,7 +353,7 @@ int RunMacro( struct dsym *macro, int idx, struct asm_tok tokenarray[], char *ou
                             continue;
                         }
                         /* count brackets */
-                        if ( parm_end_delim == T_CL_BRACKET )
+                        if ( parm_end_delim == T_CL_BRACKET ) {
                             if ( tokenarray[i].token == T_OP_BRACKET )
                                 cnt++;
                             else if ( tokenarray[i].token == T_CL_BRACKET ) {
@@ -361,6 +361,7 @@ int RunMacro( struct dsym *macro, int idx, struct asm_tok tokenarray[], char *ou
                                     break;
                                 cnt--;
                             }
+                        }
 
                         /* stop if undelimited string occurs (need to scan for '!') */
                         if ( tokenarray[i].token == T_STRING && tokenarray[i].string_delim == NULLC )
@@ -483,7 +484,7 @@ int RunMacro( struct dsym *macro, int idx, struct asm_tok tokenarray[], char *ou
                      * text macros are expanded only selectively
                      */
                     if ( tokenarray[idx].token == T_ID ) {
-                        if ( sym = SymSearch( tokenarray[idx].string_ptr ) ) {
+                        if ( (sym = SymSearch( tokenarray[idx].string_ptr )) != NULL ) {
                             if ( sym->state == SYM_MACRO && sym->isdefined == TRUE &&
                                 sym->isfunc == TRUE && tokenarray[idx+1].token == T_OP_BRACKET ) {
                                 bool is_exitm2;
diff --git a/expreval.c b/expreval.c
index c8112978..67b29b7d 100644
--- a/expreval.c
+++ b/expreval.c
@@ -367,8 +367,7 @@ static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok to
             break;
 
         if ( f->next != NULL ) {
-
-            if ( tokenarray[i].token != T_FINAL )
+            if ( tokenarray[i].token != T_FINAL ) {
                 if ( tokenarray[i].token == T_COMMA )
                     i++;
                 else {
@@ -376,6 +375,7 @@ static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok to
                     while ( tokenarray[i].token != T_FINAL && tokenarray[i].token != T_COMMA )
                         i++;
                 }
+            }
         }
     }  /* end for */
     opnd1->llvalue = dwRecInit;
diff --git a/extern.c b/extern.c
index fd084624..508c4874 100644
--- a/extern.c
+++ b/extern.c
@@ -356,13 +356,14 @@ ret_code ExterndefDirective( int i, struct asm_tok tokenarray[] )
         }
 #endif
 
-        if ( tokenarray[i].token != T_FINAL )
+        if ( tokenarray[i].token != T_FINAL ) {
             if ( tokenarray[i].token == T_COMMA ) {
                 if ( (i + 1) < Token_Count )
                     i++;
             } else {
                 return( EmitErr( EXPECTING_COMMA, tokenarray[i].tokpos ) );
             }
+        }
 
     } while ( i < Token_Count );
 
@@ -655,12 +656,13 @@ ret_code ExternDirective( int i, struct asm_tok tokenarray[] )
 
         SetMangler( sym, langtype, mangle_type );
 
-        if ( tokenarray[i].token != T_FINAL )
+        if ( tokenarray[i].token != T_FINAL ) {
             if ( tokenarray[i].token == T_COMMA &&  ( (i + 1) < Token_Count ) ) {
                 i++;
             } else {
                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
             }
+        }
     }  while ( i < Token_Count );
 
     return( NOT_ERROR );
@@ -917,7 +919,7 @@ ret_code PublicDirective( int i, struct asm_tok tokenarray[] )
         sym = SymSearch( token );
         if ( Parse_Pass == PASS_1 ) {
             if ( sym == NULL ) {
-                if ( sym = SymCreate( token ) ) {
+                if ( (sym = SymCreate( token )) != NULL ) {
                     sym_add_table( &SymTables[TAB_UNDEF], (struct dsym *)sym );
                     DebugMsg1(("PublicDirective(%s): new symbol\n", sym->name ));
                 } else
@@ -967,13 +969,14 @@ ret_code PublicDirective( int i, struct asm_tok tokenarray[] )
             }
         }
 
-        if ( tokenarray[i].token != T_FINAL )
+        if ( tokenarray[i].token != T_FINAL ) {
             if ( tokenarray[i].token == T_COMMA ) {
                 if ( (i + 1) < Token_Count )
                     i++;
             } else {
                 return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].tokpos ) );
             }
+        }
 
     } while ( i < Token_Count );
 
diff --git a/hll.c b/hll.c
index d5bb4f1f..7fc4ad19 100644
--- a/hll.c
+++ b/hll.c
@@ -913,7 +913,7 @@ static void ReplaceLabel(char* p, uint_32 olabel, uint_32 nlabel)
     i = (int)strlen(newlbl);
 
     DebugMsg1(("%u ReplaceLabel(%s->%s, >%s<)\n", evallvl, oldlbl, newlbl, p));
-    while (p = strstr(p, oldlbl)) {
+    while ( (p = strstr(p, oldlbl)) != NULL ) {
         memcpy(p, newlbl, i);
         p += i;
     }
@@ -1090,7 +1090,7 @@ static ret_code QueueTestLines(char* src)
     while (src) {
         //if (*src == ' ') src++; /* v2.11: obsolete */
         start = src;
-        if (src = strchr(src, EOLCHAR))
+        if ( (src = strchr(src, EOLCHAR)) != NULL )
             *src++ = NULLC;
         if (*start)
             AddLineQueue(start);
diff --git a/input.c b/input.c
index afe0460a..2104081e 100644
--- a/input.c
+++ b/input.c
@@ -620,7 +620,7 @@ FILE *SearchFile( const char *path, bool queue )
                      */
                     memcpy( fullpath, src, i );
                     strcpy( fullpath + i, path );
-                    if ( file = fopen( fullpath, "rb" ) ) {
+                    if ( (file = fopen( fullpath, "rb" )) != NULL ) {
                         DebugMsg1(("SearchFile(): file found, fopen(%s)=%X\n", fullpath, file ));
                         path = fullpath;
 						if(file) 
@@ -646,7 +646,7 @@ FILE *SearchFile( const char *path, bool queue )
          * and NO absolute path is given, then search include dirs
          */
         if( file == NULL && ModuleInfo.g.IncludePath != NULL && !isabs ) {
-            if ( file = open_file_in_include_path( path, fullpath ) ) {
+            if ( (file = open_file_in_include_path( path, fullpath )) != NULL ) {
                 DebugMsg1(("SearchFile(): open_file_in_include_path(%s)=%X [%s]\n", path, file, fullpath ));
                 path = fullpath;
             }
diff --git a/invoke.c b/invoke.c
index cbcc0614..3ce8523e 100644
--- a/invoke.c
+++ b/invoke.c
@@ -1005,7 +1005,7 @@ static int ms64_param(struct dsym const *proc, int index, struct dsym *param, bo
 		if (addr || psize > 8) { /* psize > 8 should happen only for vectorcall */
 			if (psize >= 4) {
 				if (proc->sym.langtype == LANG_VECTORCALL) {
-					if ((param->sym.mem_type == MT_TYPE)) {
+					if (param->sym.mem_type == MT_TYPE) {
 						t = param->sym.ttype;
 
 						if (vcallpass == 0 && opnd->kind == EXPR_REG && opnd->indirect == FALSE && reg < T_XMM6 && index < 6 && info->xyzused[(reg - T_XMM0)] != 0 && (index != reg - T_XMM0))
@@ -1580,15 +1580,22 @@ static int sysv_GetNextGPR(struct proc_info *info, int size)
 /* Return the first free Vector register useable in a SystemV invoke/call */
 static int sysv_GetNextVEC(struct proc_info *info, int size)
 {
-	//int base = 0;
 	if (info->firstVEC >= 8)
 		return(-1);
-	if(size == 16)
+
+	switch (size)
+	{
+	case 16:
 		return(sysV64_regsXMM[info->firstVEC++]);
-	if (size == 32)
+	case 32:
 		return(sysV64_regsYMM[info->firstVEC++]);
-	if (size == 64)
+	case 64:
 		return(sysV64_regsZMM[info->firstVEC++]);
+	default:
+		break;
+	}
+
+	return(-1);
 }
 
 /*
@@ -3051,8 +3058,8 @@ static int watc_param(struct dsym const *proc, int index, struct dsym *param, bo
 		i = 0;
 		if (reg[1] != NULL) {
 			char buffer[128];
-			short sreg;
-			if (sreg = GetSegmentPart(opnd, buffer, paramvalue))
+			short sreg = GetSegmentPart(opnd, buffer, paramvalue);
+			if (sreg)
 				AddLineQueueX("%r %s, %r", T_MOV, reg[0], sreg);
 			else
 				AddLineQueueX("%r %s, %s", T_MOV, reg[0], buffer);
@@ -3842,7 +3849,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 						}
 						else if (pushsize == 2) { /* 16-bit code? */
 							if (opnd.mem_type == MT_BYTE) {
-								if (psize == 4)
+								if (psize == 4) {
 									if ((ModuleInfo.curr_cpu & P_CPU_MASK) < P_186) {
 										if (!(*r0flags & R0_X_CLEARED))
 											AddLineQueueX(" xor %r, %r", T_AX, T_AX);
@@ -3851,6 +3858,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 									}
 									else
 										AddLineQueue(" push 0");
+								}
 								AddLineQueueX(" mov %r, %s", T_AL, fullparam);
 								if (!(*r0flags & R0_H_CLEARED)) {
 									AddLineQueueX(" mov %r, 0", T_AH);
@@ -4094,7 +4102,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 									*r0flags |= R0_USED;
 									*r0flags &= ~R0_X_CLEARED;
 								}
-								if (psize != 1) /* v2.11: don't modify AH if paramsize is 1 */
+								if (psize != 1) { /* v2.11: don't modify AH if paramsize is 1 */
 									if (IS_SIGNED(opnd.mem_type)) {
 										AddLineQueue(" cbw");
 										*r0flags &= ~(R0_H_CLEARED | R0_X_CLEARED);
@@ -4103,6 +4111,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 										AddLineQueueX(" mov %r, 0", T_AH);
 										*r0flags |= R0_H_CLEARED;
 									}
+								}
 							}
 							reg = regax[ModuleInfo.Ofssize];
 						}
@@ -4162,7 +4171,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 				//asize = CurrWordSize;
 				asize = 2 << Ofssize;
 
-				if (psize < asize)  /* ensure that the default argsize (2,4,8) is met */
+				if (psize < asize) { /* ensure that the default argsize (2,4,8) is met */
 					if (psize == 0 && curr->sym.is_vararg) {
 						/* v2.04: push a dword constant in 16-bit */
 						if (asize == 2 &&
@@ -4170,9 +4179,10 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 							psize = 4;
 						else
 							psize = asize;
-					}
-					else
+					} else {
 						psize = asize;
+					}
+				}
 
 				if ((ModuleInfo.curr_cpu & P_CPU_MASK) < P_186) {
 					*r0flags |= R0_USED;
diff --git a/label.c b/label.c
index 1513870c..d2ef660c 100644
--- a/label.c
+++ b/label.c
@@ -267,13 +267,14 @@ ret_code LabelDirective( int i, struct asm_tok tokenarray[] )
         LstWrite( LSTTYPE_LABEL, 0, NULL );
 
     /* v2.08: if label is a DATA label, set total_size and total_length */
-    if ( sym = CreateLabel( tokenarray[0].string_ptr, ti.mem_type, &ti, FALSE ) ) {
+    sym = CreateLabel( tokenarray[0].string_ptr, ti.mem_type, &ti, FALSE );
+    if ( sym ) {
         DebugMsg1(("LabelDirective(%s): label created, memtype=%Xh size=%u\n", sym->name, sym->mem_type, ti.size ));
         /* sym->isdata must be 0, else the LABEL directive was generated within data_item()
          * and fields total_size & total_length must not be modified then!
          * v2.09: data_item() no longer creates LABEL directives.
          */
-        if ( sym->isdata == FALSE && ( sym->mem_type & MT_SPECIAL_MASK ) != MT_ADDRESS )
+        if ( sym->isdata == FALSE && ( sym->mem_type & MT_SPECIAL_MASK ) != MT_ADDRESS ) {
 #if LABELARRAY
             if ( length != -1 ) {
                 sym->total_size = ti.size * length;
@@ -285,6 +286,7 @@ ret_code LabelDirective( int i, struct asm_tok tokenarray[] )
                 sym->total_size = ti.size;
                 sym->total_length = 1;
             }
+        }
         return( NOT_ERROR );
     }
     return( ERROR );
diff --git a/macho64.c b/macho64.c
index 906c96c3..2ef6dfd8 100644
--- a/macho64.c
+++ b/macho64.c
@@ -197,7 +197,7 @@ int macho_build_string_tbl(struct symtab_command *pSymCmd, struct macho_module *
 	int totalSymCount = 0;
 
 	/* Normal local symbols */
-	while (sym = SymEnum(sym, &i))
+	while ( (sym = SymEnum(sym, &i)) != NULL )
 	{
 		if (strcmp(sym->name, "$xdatasym") == 0) continue;
 		if (sym->state != SYM_MACRO && sym->state != SYM_SEG && sym->state != SYM_TMACRO && sym->predefined == 0 && sym->state != SYM_GRP && sym->isequate == 0)
@@ -218,7 +218,7 @@ int macho_build_string_tbl(struct symtab_command *pSymCmd, struct macho_module *
 	mm->extSymIdx = totalSymCount;
 
 	/* External public symbols */
-	while (sym = SymEnum(sym, &i))
+	while ( (sym = SymEnum(sym, &i)) != NULL )
 	{
 		if (sym->state != SYM_MACRO && sym->state != SYM_SEG && sym->state != SYM_TMACRO && sym->predefined == 0 && sym->state != SYM_GRP && sym->isequate == 0)
 		{
@@ -238,7 +238,7 @@ int macho_build_string_tbl(struct symtab_command *pSymCmd, struct macho_module *
 	mm->undefSymIdx = totalSymCount;
 
 	/* Undefined symbols */
-	while (sym = SymEnum(sym, &i))
+	while ( (sym = SymEnum(sym, &i)) != NULL )
 	{
 		if (sym->state != SYM_MACRO && sym->state != SYM_SEG && sym->state != SYM_TMACRO && sym->predefined == 0 && sym->state != SYM_GRP && sym->isequate == 0)
 		{
diff --git a/macro.c b/macro.c
index bcdd6e44..bbd79653 100644
--- a/macro.c
+++ b/macro.c
@@ -209,7 +209,8 @@ static int store_placeholders( char *line, struct mname_list *mnames )
             substprf = ( ( start > line && *(start-1) == '&') || *p == '&' );
             if ( quote == NULLC || substprf ) {
                 /* look for this word in the macro parms, and replace it if it is */
-                if ( start = replace_parm( line, start, p - start, mnames ) ) {
+                start = replace_parm( line, start, p - start, mnames );
+                if ( start ) {
                     params++;
                     p = start;
                 }
@@ -939,7 +940,7 @@ struct dsym *CreateMacro( const char *name )
 /******************************************/
 {
     struct dsym *macro;
-    if ( macro = (struct dsym *)SymCreate( name ) ) {
+    if ( (macro = (struct dsym *)SymCreate( name )) != NULL ) {
         macro->sym.state = SYM_MACRO;
         macro->e.macroinfo = LclAlloc( sizeof( struct macro_info ) );
         macro->e.macroinfo->parmcnt  = 0;
@@ -1150,10 +1151,12 @@ ret_code DefineDirective( int i, struct asm_tok tokenarray[] )
     strcat(p, " EQU 1\0");
     strcpy(tokenarray[0].tokpos,buff);
     Token_Count = Tokenize(tokenarray[0].tokpos, 0, tokenarray, 0);
-  if ( sym = CreateConstant( tokenarray ) ) {
+  if ( (sym = CreateConstant( tokenarray )) != NULL ) {
       if ( sym->state != SYM_TMACRO ) {
 #if FASTPASS
-          if ( StoreState ) FStoreLine( 0 );
+          if ( StoreState ) {
+            FStoreLine( 0 ) {}
+          }
 #endif
           if ( Options.preprocessor_stdout == TRUE )
               WritePreprocessedLine( CurrSource );
diff --git a/omf.c b/omf.c
index fe804643..51b16a84 100644
--- a/omf.c
+++ b/omf.c
@@ -1532,7 +1532,8 @@ static void omf_write_header_dbgcv( void )
     AttachData( &obj, "\001CV", 3 );
     omf_write_record( &obj );
     for ( i = 0; i < DBGS_MAX; i++ ) {
-        if ( SymDebSeg[i] = (struct dsym *)CreateIntSegment( SymDebParm[i].name, SymDebParm[i].cname, 0, USE32, TRUE ) ) {
+        SymDebSeg[i] = (struct dsym *)CreateIntSegment( SymDebParm[i].name, SymDebParm[i].cname, 0, USE32, TRUE );
+        if ( SymDebSeg[i] ) {
             SymDebSeg[i]->e.seginfo->force32 = TRUE; /* without this a 32-bit segdef is emitted only if segsize > 64kB */
             SymDebSeg[i]->e.seginfo->flushfunc = omf_cv_flushfunc;
         }
@@ -1564,6 +1565,10 @@ static ret_code omf_write_module( struct module_info *modinfo )
 #if TRUNCATE
     int fh;
     uint_32 size;
+#if defined(__UNIX__) || defined(__CYGWIN__) || defined(__DJGPP__)
+    int ret;
+#define HAVE_FTRUNCATE 1
+#endif
 #endif
     /* -if Zi is set, write symbols and types */
     if ( Options.debug_symbols )
@@ -1585,9 +1590,10 @@ static ret_code omf_write_module( struct module_info *modinfo )
      * won't become shorter anymore.
      */
     size = ftell( CurrFile[OBJ] );
-#if defined(__UNIX__) || defined(__CYGWIN__) || defined(__DJGPP__)
+#if defined(HAVE_FTRUNCATE)
     fh = fileno( CurrFile[OBJ] );
-    if ( ftruncate( fh, size ) ); /* gcc warns if return value of ftruncate() is "ignored" */
+    ret = ftruncate( fh, size );
+    (void)ret;
 #elif defined(__BORLANDC__)
     fh = _fileno( CurrFile[OBJ] );
     chsize( fh, size );
diff --git a/parser.c b/parser.c
index dbb2dd45..17a737c9 100644
--- a/parser.c
+++ b/parser.c
@@ -1770,7 +1770,8 @@ static ret_code memory_operand( struct code_info *CodeInfo, unsigned CurrOpnd, s
     {
         return(EmitError(USE_OF_REGISTER_ASSUMED_TO_ERROR));
     }
-    if (index != EMPTY && GetValueSp(index) & OP_XMM == 0 && GetValueSp(index) & OP_YMM == 0 && StdAssumeTable[GetRegNo(index)].error)
+    if (index != EMPTY && (GetValueSp(index) & OP_XMM) == 0 &&
+        (GetValueSp(index) & OP_YMM) == 0 && StdAssumeTable[GetRegNo(index)].error)
     {
         return(EmitError(USE_OF_REGISTER_ASSUMED_TO_ERROR));
     }
@@ -1924,11 +1925,12 @@ static ret_code memory_operand( struct code_info *CodeInfo, unsigned CurrOpnd, s
 		
 		/* v2.10: added; IMAGEREL/SECTIONREL for indirect memory operands */
 		#if IMAGERELSUPP || SECTIONRELSUPP 
-        if ( fixup_type == FIX_OFF32 )
+        if ( fixup_type == FIX_OFF32 ) {
             if ( opndx->instr == T_IMAGEREL )
                 fixup_type = FIX_OFF32_IMGREL;
             else if ( opndx->instr == T_SECTIONREL )
                 fixup_type = FIX_OFF32_SECREL;
+        }
 		#endif
 
         /* no fixups are needed for memory operands of string instructions and XLAT/XLATB.
@@ -2158,11 +2160,12 @@ static ret_code process_register( struct code_info *CodeInfo, unsigned CurrOpnd,
             CodeInfo->iswide = 0;
 
 #if AMD64_SUPPORT
-        if ( CodeInfo->Ofssize == USE64 && regno >=4 && regno <=7 )
+        if ( CodeInfo->Ofssize == USE64 && regno >=4 && regno <=7 ) {
             if ( SpecialTable[regtok].cpu == P_86 )
                 CodeInfo->x86hi_used = 1; /* it's AH,BH,CH,DH */
             else
                 CodeInfo->x64lo_used = 1; /* it's SPL,BPL,SIL,DIL */
+        }
 #endif
         if ( StdAssumeTable[regno].error & (( regtok >= T_AH && regtok <= T_BH ) ? RH_ERROR : RL_ERROR ) ) 
 		{
@@ -2371,11 +2374,12 @@ static void HandleStringInstructions( struct code_info *CodeInfo, const struct e
     case T_MOVQ:
 #endif
         /* movs allows prefix for the second operand (=source) only */
-        if ( CodeInfo->prefix.RegOverride != EMPTY )
+        if ( CodeInfo->prefix.RegOverride != EMPTY ) {
             if ( opndx[OPND2].override == NULL )
                 EmitError( INVALID_INSTRUCTION_OPERANDS );
             else if ( CodeInfo->prefix.RegOverride == ASSUME_DS )
                 CodeInfo->prefix.RegOverride = EMPTY;
+        }
         break;
     case T_OUTS:
     case T_OUTSB:
@@ -2401,11 +2405,12 @@ static void HandleStringInstructions( struct code_info *CodeInfo, const struct e
         /* INSx, SCASx and STOSx don't allow any segment prefix != ES
          for the memory operand.
          */
-        if ( CodeInfo->prefix.RegOverride != EMPTY )
+        if ( CodeInfo->prefix.RegOverride != EMPTY ) {
             if ( CodeInfo->prefix.RegOverride == ASSUME_ES )
                 CodeInfo->prefix.RegOverride = EMPTY;
             else
                 EmitError( INVALID_INSTRUCTION_OPERANDS );
+        }
     }
 
     if ( opnd_clstab[CodeInfo->pinstr->opclsidx].opnd_type[opndidx] == OP_NONE ) {
@@ -2626,11 +2631,12 @@ static ret_code check_size( struct code_info *CodeInfo, const struct expr opndx[
         op1_size = OperandSize( op1, CodeInfo );
         op2_size = OperandSize( op2, CodeInfo );
         DebugMsg1(("check_size, MOVZX/MOVSX: op2_size=%u, opndx.memtype=%Xh, opndx.sym=%X\n", op2_size, opndx[OPND2].mem_type, opndx[OPND2].sym ));
-        if ( op2_size == 0 && Parse_Pass == PASS_2 )
+        if ( op2_size == 0 && Parse_Pass == PASS_2 ) {
             if ( op1_size == 2 ) {
                 EmitWarn( 2, SIZE_NOT_SPECIFIED_ASSUMING, "BYTE" );
             } else
                 EmitErr( INSTRUCTION_OPERAND_MUST_HAVE_SIZE );
+        }
         switch( op1_size ) {
 #if AMD64_SUPPORT
         case 8:
@@ -3325,7 +3331,8 @@ ret_code ParseLine(struct asm_tok tokenarray[]) {
 
 			case T_ID:
       
-				if (sym = IsType(tokenarray[i].string_ptr)) {
+				sym = IsType(tokenarray[i].string_ptr);
+				if (sym) {
 					return(data_dir(i, tokenarray, sym));
 				}
 				break;
@@ -3891,7 +3898,8 @@ ret_code ParseLine(struct asm_tok tokenarray[]) {
 	/* ******************************************************* */
 	if (CurrOpnd != j) 
 	{
-		for (; tokenarray[i].token != T_COMMA; i--);
+		for (; tokenarray[i].token != T_COMMA; i--)
+		{}
     if (CodeInfo.token < VEX_START) {
       return(EmitErr(SYNTAX_ERROR_EX, tokenarray[i].tokpos));
     }
diff --git a/posndir.c b/posndir.c
index 47150249..e8968129 100644
--- a/posndir.c
+++ b/posndir.c
@@ -114,7 +114,9 @@ ret_code OrgDirective( int i, struct asm_tok tokenarray[] )
             return( EmitError( MUST_BE_IN_SEGMENT_BLOCK ) );
         }
 #if FASTPASS
-        if ( StoreState == FALSE ) FStoreLine(0);
+        if ( StoreState == FALSE ) {
+            FStoreLine(0) {}
+        }
 #endif
         /* v2.04: added */
         if ( Parse_Pass == PASS_1 && CurrSeg->e.seginfo->FixupList.head )
@@ -244,7 +246,9 @@ ret_code AlignDirective( int i, struct asm_tok tokenarray[] )
         return( AlignInStruct( align_value ));
 
 #if FASTPASS
-    if ( StoreState == FALSE ) FStoreLine(0);
+    if ( StoreState == FALSE ) {
+        FStoreLine(0) {}
+    }
 #endif
     seg_align = GetCurrSegAlign(); /* # of bytes */
     if( seg_align <= 0 ) {
diff --git a/preproc.c b/preproc.c
index 9de7d6f0..b3e870a2 100644
--- a/preproc.c
+++ b/preproc.c
@@ -1204,10 +1204,12 @@ int PreprocessLine( char *line, struct asm_tok tokenarray[] )
              * handle it in ANY case and if it defines a number, the line
              * must be stored and, if -EP is set, written to stdout.
              */
-            if ( sym = CreateConstant( tokenarray ) ) {
+            if ( (sym = CreateConstant( tokenarray )) != NULL ) {
                 if ( sym->state != SYM_TMACRO ) {
 #if FASTPASS
-                    if ( StoreState ) FStoreLine( 0 );
+                    if ( StoreState ) {
+                        FStoreLine( 0 ) {}
+                    }
 #endif
                     if ( Options.preprocessor_stdout == TRUE )
                         WritePreprocessedLine( line );
diff --git a/proc.c b/proc.c
index f308c52e..4175b840 100644
--- a/proc.c
+++ b/proc.c
@@ -736,7 +736,7 @@ ret_code LocalDir(int i, struct asm_tok tokenarray[])
 			curr->nextlocal = local;
 		}
 
-		if (tokenarray[i].token != T_FINAL)
+		if (tokenarray[i].token != T_FINAL) {
 			if (tokenarray[i].token == T_COMMA) {
 				if ((i + 1) < Token_Count)
 					i++;
@@ -744,6 +744,7 @@ ret_code LocalDir(int i, struct asm_tok tokenarray[])
 			else {
 				return(EmitErr(EXPECTING_COMMA, tokenarray[i].tokpos));
 			}
+		}
 
 	} while (i < Token_Count);
 
@@ -1234,7 +1235,8 @@ static ret_code ParseParams(struct dsym *proc, int i, struct asm_tok tokenarray[
 #endif
 			for (; cntParam; cntParam--)
 			{
-				for (curr = 1, paranode = proc->e.procinfo->paralist; curr < cntParam; paranode = paranode->nextparam, curr++);
+				for (curr = 1, paranode = proc->e.procinfo->paralist; curr < cntParam; paranode = paranode->nextparam, curr++)
+				{}
 				DebugMsg1(("ParseParams: parm=%s, ofs=%u, size=%d\n", paranode->sym.name, offset, paranode->sym.total_size));
 				if (paranode->sym.state == SYM_TMACRO) /* register param? */
 					;
@@ -4869,6 +4871,8 @@ static ret_code write_generic_prologue(struct proc_info *info)
 			AddLineQueueX("push %r", *regist);
 		}
 	}
+
+	return(NOT_ERROR);
 }
 
 /* Write out UASM internal prologue */
@@ -4908,11 +4912,12 @@ static ret_code write_default_prologue(void)
 runqueue:
 
 	/* special case: generated code runs BEFORE the line.*/
-	if (ModuleInfo.list && UseSavedState)
+	if (ModuleInfo.list && UseSavedState) {
 		if (Parse_Pass == PASS_1)
 			info->prolog_list_pos = list_pos;
 		else
 			list_pos = info->prolog_list_pos;
+	}
 
 	/* line number debug info also needs special treatment
 	* because current line number is the first true src line
diff --git a/string.c b/string.c
index 0c3c5d67..d28cb6bf 100644
--- a/string.c
+++ b/string.c
@@ -636,7 +636,7 @@ ret_code SizeStrDir( int i, struct asm_tok tokenarray[] )
     //sizestr = GetLiteralValue( StringBufferEnd, tokenarray[2].string_ptr );
     sizestr = tokenarray[2].stringlen;
 
-    if ( sym = CreateVariable( tokenarray[0].string_ptr, sizestr ) ) {
+    if ( (sym = CreateVariable( tokenarray[0].string_ptr, sizestr )) != NULL ) {
         DebugMsg1(("SizeStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, sizestr));
         LstWrite( LSTTYPE_EQUATE, 0, sym );
         return( NOT_ERROR );
@@ -744,7 +744,7 @@ ret_code InStrDir( int i, struct asm_tok tokenarray[] )
     if ( ( start > 0 ) && ( sizestr >= j ) && j && ( string1 = strstr( p, q ) ))
         strpos = string1 - src + 1;
 
-    if ( sym = CreateVariable( tokenarray[0].string_ptr, strpos ) ) {
+    if ( (sym = CreateVariable( tokenarray[0].string_ptr, strpos )) != NULL ) {
         DebugMsg1(("InStrDir(%s) exit, value=%u\n", tokenarray[0].string_ptr, strpos));
         LstWrite( LSTTYPE_EQUATE, 0, sym );
         return ( NOT_ERROR );
diff --git a/symbols.c b/symbols.c
index 7c272149..2a89151f 100644
--- a/symbols.c
+++ b/symbols.c
@@ -1022,7 +1022,7 @@ void WriteSymbols()
 		ld = fopen(pName, "wb");
 		sym = NULL;
 		fseek(ld, 4, SEEK_SET);
-		while (sym = SymEnum(sym, &i)) 
+		while ( (sym = SymEnum(sym, &i)) != NULL )
 		{
 			if ((sym->state == SYM_INTERNAL && sym->offset==0 && !sym->isproc) || sym->state == SYM_MACRO || sym->state == SYM_TMACRO || sym->state == SYM_GRP) continue;
 			if (sym->state == SYM_TYPE && sym->typekind != TYPE_TYPEDEF && sym->cvtyperef == 0) 
diff --git a/types.c b/types.c
index 8bdc4963..dfe9ad06 100644
--- a/types.c
+++ b/types.c
@@ -103,13 +103,13 @@ struct asym *SearchNameInStruct( const struct asym *tstruct, const char *name, u
         if ( *( fl->sym.name ) == NULLC ) {
             /* there are 2 cases: an anonymous inline struct ... */
             if ( fl->sym.state == SYM_TYPE ) {
-                if ( sym = SearchNameInStruct( &fl->sym, name, poffset, level ) ) {
+                if ( (sym = SearchNameInStruct( &fl->sym, name, poffset, level )) != NULL ) {
                     *poffset += fl->sym.offset;
                     break;
                 }
             /* or an anonymous structured field */
             } else if ( fl->sym.mem_type == MT_TYPE ) {
-                if ( sym = SearchNameInStruct( fl->sym.type, name, poffset, level ) ) {
+                if ( (sym = SearchNameInStruct( fl->sym.type, name, poffset, level )) != NULL ) {
                     *poffset += fl->sym.offset;
                     break;
                 }

From 3946571dab2c4f0b596ff36abb230e4558498ae9 Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Sat, 19 Oct 2024 20:53:01 +0200
Subject: [PATCH 06/11] clang warnings -Wunsequenced -Wpointer-bool-conversion
 -Wdeprecated-non-prototype

---
 Makefile-Linux.mak |  1 -
 codegen.c          |  9 ++++++---
 listing.c          | 24 +++++++++++++++++++++---
 proc.c             |  4 ++--
 4 files changed, 29 insertions(+), 9 deletions(-)

diff --git a/Makefile-Linux.mak b/Makefile-Linux.mak
index 07c90143..855d4eee 100644
--- a/Makefile-Linux.mak
+++ b/Makefile-Linux.mak
@@ -29,7 +29,6 @@ else
 CC = clang
 extra_c_flags += -Wno-incompatible-pointer-types-discards-qualifiers
 extra_c_flags += -Wno-pointer-sign -Wno-switch -Wno-enum-conversion -Wno-enum-compare -Wno-comment
-extra_c_flags += -Wno-unsequenced -Wno-pointer-bool-conversion -Wno-deprecated-non-prototype
 endif
 
 c_flags =-D __UNIX__ $(extra_c_flags)
diff --git a/codegen.c b/codegen.c
index d4d57f80..dc7513f1 100644
--- a/codegen.c
+++ b/codegen.c
@@ -2467,7 +2467,8 @@ static void output_opc(struct code_info *CodeInfo)
                   tmp |= MOD_10;
                   tmp |= RM_SIB;
                   c = CodeInfo->indexreg;
-                  c = (c &= 0x7) << 3;
+                  c &= 0x7;
+                  c = c << 3;
                   CodeInfo->sib |= c;
                   c = CodeInfo->basereg;
                   c &= 0x7;
@@ -2496,7 +2497,8 @@ static void output_opc(struct code_info *CodeInfo)
                       tmp |= RM_SIB;
                       if (CodeInfo->indexreg != 0xFF){
                         c = CodeInfo->indexreg;
-                        c = (c &= 0x07) << 3;
+                        c &= 0x07;
+                        c = c << 3;
                         CodeInfo->sib |= c;
                         c = CodeInfo->basereg;
                         c &= 0x7;
@@ -2544,7 +2546,8 @@ static void output_opc(struct code_info *CodeInfo)
           if (!comprdsp) CodeInfo->tuple = 0;
           if (CodeInfo->indexreg != 0xFF){
             c = CodeInfo->indexreg;
-            c = (c &= 0x07) << 3;
+            c &= 0x07;
+            c = c << 3;
             CodeInfo->sib |= c;
             c = CodeInfo->basereg;
             c &= 0x7;
diff --git a/listing.c b/listing.c
index 3aa4c30c..e38abf6f 100644
--- a/listing.c
+++ b/listing.c
@@ -190,8 +190,7 @@ void LstWrite(enum lsttype type, uint_32 oldofs, void* value)
 #endif
 
     ll.next = NULL;
-	if(ll.buffer)
-		memset( ll.buffer, ' ', sizeof( ll.buffer ) );
+	memset( ll.buffer, ' ', sizeof( ll.buffer ) );
     srcfile = get_curr_srcfile();
 
     switch ( type ) {
@@ -1136,7 +1135,26 @@ void LstWriteCRef( void )
                 }
             }
             for( dir = queues[cr[idx].type].head; dir ; dir = dir->next ) {
-                cr[idx].function( &dir->sym, ( cr[idx].flags & PRF_ADDSEG ) ? queues[LQ_SEGS].head : NULL, 0 );
+                //cr[idx].function( &dir->sym, ( cr[idx].flags & PRF_ADDSEG ) ? queues[LQ_SEGS].head : NULL, 0 );
+                void (*fptr)() = cr[idx].function;
+
+#define LOG_ARG2 ( cr[idx].flags & PRF_ADDSEG ) ? queues[LQ_SEGS].head : NULL
+
+                if (fptr == log_macro) {
+                    log_macro( &dir->sym );
+                } else if (fptr == log_struct) {
+                    log_struct( &dir->sym, LOG_ARG2, 0 );
+                } else if (fptr == log_record) {
+                    log_record( &dir->sym );
+                } else if (fptr == log_typedef) {
+                    log_typedef( &dir->sym );
+                } else if (fptr == log_segment) {
+                    log_segment( &dir->sym, LOG_ARG2 );
+                } else if (fptr == log_group) {
+                    log_group( &dir->sym, LOG_ARG2 );
+                } else if (fptr == log_proc) {
+                    log_proc( &dir->sym );
+                }
             }
         }
     }
diff --git a/proc.c b/proc.c
index 4175b840..3824397c 100644
--- a/proc.c
+++ b/proc.c
@@ -3428,7 +3428,7 @@ static void write_win64_default_prologue_RSP(struct proc_info *info)
 			if (CurrProc->sym.langtype == LANG_VECTORCALL) {
 				vectstart = info->localsize + info->xmmsize & ~(16 - 1);
 				if (info->vecused) {
-					if (info->vecregs) {
+					//if (info->vecregs) {  // address of array 'info->vecregs' will always evaluate to 'true'
 						for (n = 0, m = 0, xsize = 0; n < 6; n++) {
 							xreg = info->vecregs[n];
 							if (xreg == 1 && info->vecregsize[n] < 16)
@@ -3559,7 +3559,7 @@ static void write_win64_default_prologue_RSP(struct proc_info *info)
 								}
 							}
 						}
-					}
+					//}
 				}
 			}
 		}

From 98472b800a6733a565d530dd06f42576544827b4 Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Sat, 19 Oct 2024 21:30:39 +0200
Subject: [PATCH 07/11] clang warnings -Wpointer-sign -Wcomment
 -Wincompatible-pointer-types-discards-qualifiers

---
 H/instruct.h       |  4 ++--
 Makefile-Linux.mak |  3 +--
 assemble.c         |  2 +-
 coff.c             | 20 +++++++++---------
 data.c             |  6 +++---
 dbgcv.c            | 14 ++++++-------
 hll.c              |  6 +++---
 macho64.c          |  2 +-
 main.c             |  2 +-
 omf.c              | 52 +++++++++++++++++++++++-----------------------
 segment.c          |  2 +-
 11 files changed, 56 insertions(+), 57 deletions(-)

diff --git a/H/instruct.h b/H/instruct.h
index fbd8f983..2e71044b 100644
--- a/H/instruct.h
+++ b/H/instruct.h
@@ -1240,7 +1240,7 @@ insx(SWAPGS, swapgs,            OpCls( NONE,     NONE,       NONE ), F_0F,   0,
 insx(SYSCALL_, syscall,         OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x05,     0x00,       P_64,       0,        RWF_X64)
 insx(SYSRET, sysret,            OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x07,     0x00,       P_64,       0,        RWF_X64)
 
-/* #if 0 /* v2.09: added, inactive ( not supported by ML64 v8,9,10 ) */
+//#if 0 /* v2.09: added, inactive ( not supported by ML64 v8,9,10 ) */
 insx(FXRSTOR64, fxrstor64,      OpCls( M_ANY,    NONE,       NONE ), F_480F, 0,  no_WDS, 0xAE,     0x08,       P_64,       0,        RWF_X64)
 insx(FXSAVE64, fxsave64,        OpCls( M_ANY,    NONE,       NONE ), F_480F, 0,  no_WDS, 0xAE,     0x00,       P_64,       0,        RWF_X64)
 #if SSE4SUPP
@@ -1248,7 +1248,7 @@ insx(XRSTOR64, xrstor64,        OpCls( M_ANY,    NONE,       NONE ), F_480F, 0,
 insx(XSAVE64, xsave64,          OpCls( M_ANY,    NONE,       NONE ), F_480F, 0,  no_WDS, 0xAE,     0x20,       P_64|P_SSE4,0,        RWF_X64)
 insx(XSAVEOPT64, xsaveopt64,    OpCls( M_ANY,    NONE,       NONE ), F_480F, 0,  no_WDS, 0xAE,     0x30,       P_64|P_SSE4,0,        RWF_X64)
 #endif
-/*#endif*/
+//#endif
 #endif
 
 #if SSE4SUPP
diff --git a/Makefile-Linux.mak b/Makefile-Linux.mak
index 855d4eee..6da1588e 100644
--- a/Makefile-Linux.mak
+++ b/Makefile-Linux.mak
@@ -27,8 +27,7 @@ CC = gcc
 extra_c_flags += -Wno-discarded-qualifiers
 else
 CC = clang
-extra_c_flags += -Wno-incompatible-pointer-types-discards-qualifiers
-extra_c_flags += -Wno-pointer-sign -Wno-switch -Wno-enum-conversion -Wno-enum-compare -Wno-comment
+extra_c_flags += -Wno-switch -Wno-enum-conversion -Wno-enum-compare
 endif
 
 c_flags =-D __UNIX__ $(extra_c_flags)
diff --git a/assemble.c b/assemble.c
index b5807f5b..d6c1173c 100644
--- a/assemble.c
+++ b/assemble.c
@@ -408,7 +408,7 @@ void OutputBytes( const unsigned char *pbytes, int len, struct fixup *fixup )
 void OutputInterleavedBytes(const unsigned char *pbytes, int len, struct fixup *fixup)
 {
 	int i = 0;
-	char *pOut = NULL;
+	unsigned char *pOut = NULL;
 
 	if (write_to_file == TRUE) {
 		uint_32 idx = CurrSeg->e.seginfo->current_loc - CurrSeg->e.seginfo->start_loc;
diff --git a/coff.c b/coff.c
index f1350df4..2de90182 100644
--- a/coff.c
+++ b/coff.c
@@ -343,7 +343,7 @@ static void coff_write_symbol(char* name, int_32 strpos, int_32 value,
     IMAGE_SYMBOL sym;
 
     if (name) {
-        strncpy(sym.N.ShortName, name, IMAGE_SIZEOF_SHORT_NAME);
+        strncpy((char *)sym.N.ShortName, name, IMAGE_SIZEOF_SHORT_NAME);
     }
     else {
         sym.N.LongName[0] = 0;
@@ -1072,7 +1072,7 @@ static void coff_create_drectve( struct module_info *modinfo, struct coffmod *cm
             struct dsym *tmp;
             int size = 0;
             struct qitem *q;
-            uint_8 *p;
+            char *p;
             cm->directives->e.seginfo->info = TRUE;
 
             /* calc the size for this segment */
@@ -1116,7 +1116,7 @@ static void coff_create_drectve( struct module_info *modinfo, struct coffmod *cm
 
             cm->directives->sym.max_offset = size;
             cm->directives->e.seginfo->CodeBuffer = LclAlloc( size + 1 );
-            p = cm->directives->e.seginfo->CodeBuffer;
+            p = (char *)cm->directives->e.seginfo->CodeBuffer;
 
             /* copy the data */
 
@@ -1125,22 +1125,22 @@ static void coff_create_drectve( struct module_info *modinfo, struct coffmod *cm
                 if( tmp->e.procinfo->isexport ) {
                     Mangle( &tmp->sym, buffer );
                     if ( Options.no_export_decoration == FALSE )
-                        p += sprintf( (char *)p, "-export:%s ", buffer );
+                        p += sprintf( p, "-export:%s ", buffer );
                     else
-                        p += sprintf( (char *)p, "-export:%s=%s ", tmp->sym.name, buffer );
+                        p += sprintf( p, "-export:%s=%s ", tmp->sym.name, buffer );
                 }
             }
             /* 2. libraries */
             for( q = modinfo->g.LibQueue.head; q ; q = q->next ) {
                 if ( *q->value != '"' && strchr( q->value, ' ' ) )
-                    p += sprintf( (char *)p,"-defaultlib:\"%s\" ", (char *)q->value );
+                    p += sprintf( p,"-defaultlib:\"%s\" ", (char *)q->value );
                 else
-                    p += sprintf( (char *)p,"-defaultlib:%s ", (char *)q->value );
+                    p += sprintf( p,"-defaultlib:%s ", (char *)q->value );
             }
             /* 3. entry */
             if ( modinfo->g.start_label ) {
                 GetStartLabel( buffer, FALSE );
-                p += sprintf( (char *)p, "-entry:%s ", buffer );
+                p += sprintf( p, "-entry:%s ", buffer );
             }
             /* 4. impdefs */
             for( tmp = imp; tmp ; tmp = tmp->next ) {
@@ -1160,7 +1160,7 @@ static void coff_create_drectve( struct module_info *modinfo, struct coffmod *cm
             }
             /* 5. pragma comment(linker,"/..") */
             for (q = modinfo->g.LinkQueue.head; q; q = q->next) {
-                p += sprintf((char*)p, "%s ", (char*)q->value);
+                p += sprintf(p, "%s ", (char*)q->value);
             }
          }
     }
@@ -1196,7 +1196,7 @@ static ret_code coff_write_module( struct module_info *modinfo )
                 break;
             cm.SymDeb[i].seg->e.seginfo->characteristics = (IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE) >> 24;
             /* use the source line buffer as code buffer. It isn't needed anymore */
-            cm.SymDeb[i].seg->e.seginfo->CodeBuffer = CurrSource + i * SIZE_CV_SEGBUF;
+            cm.SymDeb[i].seg->e.seginfo->CodeBuffer = (uint_8 *)(CurrSource + i * SIZE_CV_SEGBUF);
             cm.SymDeb[i].seg->e.seginfo->flushfunc = coff_flushfunc;
             cm.SymDeb[i].q.head = NULL;
         }
diff --git a/data.c b/data.c
index d7fbbbfe..e8b941b6 100644
--- a/data.c
+++ b/data.c
@@ -514,7 +514,7 @@ static void output_float( const struct expr *opnd, unsigned size )
 	else {
         atofloat( buffer, opnd->float_tok->string_ptr, size, opnd->negative, opnd->float_tok->floattype );
     }
-    OutputDataBytes( buffer, size );
+    OutputDataBytes( (unsigned char *)buffer, size );
     return;
 }
 
@@ -851,7 +851,7 @@ static ret_code data_item( int *start_pos, struct asm_tok tokenarray[], struct a
 				if (Options.masm51_compat || Options.strict_masm_compat || !Options.literal_strings)
 				{
 					if (string_len > 1 && no_of_bytes > 1)
-						pchar = little_endian( (const char *)pchar, string_len );
+						pchar = (uint_8 *) little_endian( (const char *)pchar, string_len );
 					OutputDataBytes( pchar, string_len );
 					if ( no_of_bytes > string_len )
 						FillDataBytes(0, no_of_bytes - string_len);
@@ -872,7 +872,7 @@ static ret_code data_item( int *start_pos, struct asm_tok tokenarray[], struct a
                         else 
 						{
 							if(no_of_bytes > 1)
-								pchar = little_endian((const char *)pchar, string_len);
+								pchar = (uint_8 *) little_endian((const char *)pchar, string_len);
 							OutputDataBytes(pchar, string_len);
                         }
 					}
diff --git a/dbgcv.c b/dbgcv.c
index a2760500..0255d3b0 100644
--- a/dbgcv.c
+++ b/dbgcv.c
@@ -123,7 +123,7 @@ struct leaf32 {
 
 #pragma pack(pop)
 
-uint_8* SetPrefixName(uint_8* p, uint_8* name, int len)
+uint_8* SetPrefixName(uint_8* p, char* name, int len)
 {
 	if (Options.debug_symbols < CV_SIGNATURE_C13)
 		*p++ = len;
@@ -1607,7 +1607,7 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 		EnvBlock = cv.s_env;
 		EnvBlock->flags = 0;
 		EnvBlock->rectyp = S_ENVBLOCK;
-		s = EnvBlock->rgsz;
+		s = (char *)EnvBlock->rgsz;
 
 		/* pairs of 0-terminated strings - keys/values
 		 *
@@ -1623,15 +1623,15 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 		len = strlen(_pgmptr) + 1;
 		s = strcpy(s, _pgmptr) + len;
 		s = strcpy(s, "src") + 4;
-		p = cv.files[0].name;
-		if (_memicmp(p, cv.currdir, q) == 0)
+		p = (uint_8 *)cv.files[0].name;
+		if (_memicmp((const char *)p, cv.currdir, q) == 0)
 			p += q + 1;
 
-		len = strlen(p) + 1;
-		s = strcpy(s, p) + len;
+		len = strlen((const char *)p) + 1;
+		s = strcpy(s, (const char *)p) + len;
 		*s++ = '\0';
 		EnvBlock->reclen = (unsigned short)(s - (char*)cv.ps - 2);
-		cv.ps = s;
+		cv.ps = (uint_8 *)s;
 
 		/* length needs to be added for each symbol */
 
diff --git a/hll.c b/hll.c
index 7fc4ad19..1e20b458 100644
--- a/hll.c
+++ b/hll.c
@@ -352,11 +352,11 @@ static void bubblesort(struct hll_item* hll, uint_16* lbl, int* src, int n) {
     hll->delta = hll->maxcase - hll->mincase;
 }
 #if AMD64_SUPPORT 
-static void bubblesort64(struct hll_item* hll, uint_16* lbl, int_64* src, int n) {
+static void bubblesort64(struct hll_item* hll, uint_16* lbl, uint_64* src, int n) {
     /*******************************************************************************************************************************/
     int i;
     int j;
-    int_64 temp1;
+    uint_64 temp1;
     uint_16 temp2;
     for (i = 0; i < n; ++i)
     {
@@ -2869,7 +2869,7 @@ ret_code HllExitDir(int i, struct asm_tok tokenarray[])
     char* p;
     char buffer[MAX_LINE_LEN];
 #if AMD64_SUPPORT
-    int_64* newcp64;
+    uint_64* newcp64;
 #endif
 
 
diff --git a/macho64.c b/macho64.c
index 2ef6dfd8..6788b8f0 100644
--- a/macho64.c
+++ b/macho64.c
@@ -280,7 +280,7 @@ static int GetSymbolIndex(const char *pName, struct macho_module *mm)
 /* ==========================================================================================
 Build a macho_section_entry structure.
 ========================================================================================== */
-struct macho_section_entry * macho_build_section( const char *secName, const char *segName, uint32_t flags, const char *srcName )
+struct macho_section_entry * macho_build_section( const char *secName, const char *segName, uint32_t flags, char *srcName )
 {
 	struct macho_section_entry *pSec = NULL;
 	pSec = malloc(sizeof(struct macho_section_entry));
diff --git a/main.c b/main.c
index ebac9301..a42a9736 100644
--- a/main.c
+++ b/main.c
@@ -61,7 +61,7 @@ static void genfailure( int signo )
 int main(int argc, char **argv)
 /*******************************/
 {
-	char const *pEnv;
+	char    *pEnv;
 	int     numArgs = 0;
 	int     numFiles = 0;
 	int     rc = 0;
diff --git a/omf.c b/omf.c
index 51b16a84..3f54536a 100644
--- a/omf.c
+++ b/omf.c
@@ -353,7 +353,7 @@ static void omf_write_linnum( uint_8 is32 )
     struct line_num_info *next;
     struct omf_rec       obj;
 
-    for( node = LinnumQueue.head, data = StringBufferEnd; node; node = next ) {
+    for( node = LinnumQueue.head, data = (uint_8 *)StringBufferEnd; node; node = next ) {
         next = node->next;
         *(uint_16 *)data = node->number;
         data += sizeof( uint_16 );
@@ -367,7 +367,7 @@ static void omf_write_linnum( uint_8 is32 )
     if( size ) {
         omf_InitRec( &obj, CMD_LINNUM );
         obj.is_32 = is32;
-        AttachData( &obj, StringBufferEnd, size );
+        AttachData( &obj, (uint_8 *)StringBufferEnd, size );
         obj.d.linnum.base.grp_idx = omf_GetGrpIdx( GetGroup( &CurrSeg->sym ) ); /* fixme ? */
         obj.d.linnum.base.seg_idx = CurrSeg->e.seginfo->seg_idx;
         obj.d.linnum.base.frame = 0; /* field not used here */
@@ -387,7 +387,7 @@ static void omf_write_fixupp( struct dsym *seg, char is32 )
 
     fix = seg->e.seginfo->FixupList.head;
     while ( fix ) {
-        for( data = StringBufferEnd, size = 0; fix; fix = fix->nextrlc ) {
+        for( data = (uint_8 *)StringBufferEnd, size = 0; fix; fix = fix->nextrlc ) {
             switch( fix->type ) {
             case FIX_RELOFF32:
             case FIX_OFF32:
@@ -406,7 +406,7 @@ static void omf_write_fixupp( struct dsym *seg, char is32 )
         if ( size ) {
             omf_InitRec( &obj, CMD_FIXUPP );
             obj.is_32 = is32;
-            AttachData( &obj, StringBufferEnd, size );
+            AttachData( &obj, (uint_8 *)StringBufferEnd, size );
             omf_write_record( &obj );
         }
     }
@@ -434,7 +434,7 @@ static void omf_write_ledata( struct dsym *seg )
              */
             if ( seg->sym.used ) {
                 omf_InitRec( &obj, CMD_CEXTDEF );
-                AttachData( &obj, StringBufferEnd, 2 * sizeof( uint_16 ) );
+                AttachData( &obj, (uint_8 *)StringBufferEnd, 2 * sizeof( uint_16 ) );
                 PutIndex( &obj, seg->e.seginfo->comdat_idx ); /* Index */
                 PutIndex( &obj, 0 ); /* Type */
                 TruncRec( &obj );
@@ -536,7 +536,7 @@ static void omf_write_theadr( const char *name )
      * was given as filename!
      */
     len = strlen( name );
-    AttachData( &obj, StringBufferEnd, len + 1 );
+    AttachData( &obj, (uint_8 *)StringBufferEnd, len + 1 );
     PutName( &obj, name, len );
     omf_write_record( &obj );
 
@@ -732,7 +732,7 @@ static void omf_write_export( void )
             omf_InitRec( &obj, CMD_COMENT );
             obj.d.coment.attr = 0x00;
             obj.d.coment.cmt_class = CMT_OMF_EXT;
-            data = StringBufferEnd;
+            data = (uint_8 *)StringBufferEnd;
 
             /* structure of EXPDEF "comment":
              * type          db CMT_EXT_EXPDEF (=02)
@@ -744,14 +744,14 @@ static void omf_write_export( void )
              * ;ordinal      dw ?     ;optional
              */
             if ( Options.no_export_decoration == FALSE )
-                len = Mangle( &dir->sym, data+3 );
+                len = Mangle( &dir->sym, (char *)data+3 );
             else {
-                strcpy( data+3, dir->sym.name );
+                strcpy( (char *)data+3, dir->sym.name );
                 len = dir->sym.name_size;
             }
             /* v2.11: case mapping was missing */
             if ( ModuleInfo.convert_uppercase )
-                _strupr( data+3 );
+                _strupr( (char *)data+3 );
 #if MAX_ID_LEN > 255
             if ( len > 255 )
                 len = 255; /* restrict name to 255 chars */
@@ -801,7 +801,7 @@ static void omf_write_grpdef( void )
          * - 1 or 2 bytes for the group name index
          * - 2 or 3 bytes for each segment in the group
          */
-        AttachData( &grp, StringBufferEnd, 2 + 3 * curr->e.grpinfo->numseg );
+        AttachData( &grp, (uint_8 *)StringBufferEnd, 2 + 3 * curr->e.grpinfo->numseg );
         /* v2.01: the LName index of the group may be > 0xff */
         /* v2.03: use the group index directly */
         PutIndex( &grp, curr->e.grpinfo->lname_idx );
@@ -964,7 +964,7 @@ static void omf_write_lnames( void )
         memcpy( p, sym->name, sym->name_size + 1 );
         /* lnames are converted for casemaps ALL and NOTPUBLIC */
         if ( ModuleInfo.case_sensitive == FALSE )
-            _strupr( p );
+            _strupr( (char *)p );
         DebugMsg1(("omf_write_lnames: %u=%s\n", items, p ));
         p += sym->name_size; /* overwrite the null char */
         items++;
@@ -1056,13 +1056,13 @@ static uint_16 omf_write_extdef( void )
         for ( rec_size = 0, obj.d.extdef.num_names = 0; sym; sym = GetExt( &r ) ) {
             //DebugMsg(("omf_write_extdef: %s, weak=%u, used=%u\n", curr->sym.name, curr->sym.weak, curr->sym.used ));
             DebugMsg1(("omf_write_extdef: %s\n", sym->name));
-            len = Mangle( sym, buffer );
+            len = Mangle( sym, (char *)buffer );
 #if MAX_ID_LEN > 255
             if ( len > 255 )
                 len = 255; /* length is 1 byte only */
 #endif
             if ( ModuleInfo.convert_uppercase )
-                _strupr( buffer );
+                _strupr( (char *)buffer );
 
             if( rec_size + len + 2 >= MAX_EXT_LENGTH ) {
                 break;
@@ -1217,13 +1217,13 @@ static uint_16 omf_write_comdef( uint_16 index )
             numsize = 1;
             if ( curr->sym.isfar == TRUE ) {
                 number[0] = COMDEF_FAR;  /* 0x61 */
-                numsize += put_comdef_number( &number[1], curr->sym.total_length );
-                numsize += put_comdef_number( &number[numsize], varsize );
+                numsize += put_comdef_number( (uint_8 *)&number[1], curr->sym.total_length );
+                numsize += put_comdef_number( (uint_8 *)&number[numsize], varsize );
                 DebugMsg(("omf_write_comdef: numsize=%u, length=%u, varsize=%u\n",
                           numsize, curr->sym.total_length, varsize ));
             } else {
                 number[0] = COMDEF_NEAR; /* 0x62 */
-                numsize += put_comdef_number( &number[1], curr->sym.total_length * varsize );
+                numsize += put_comdef_number( (uint_8 *)&number[1], curr->sym.total_length * varsize );
                 DebugMsg1(("omf_write_comdef: numsize=%u, value=%u\n",
                           numsize, curr->sym.total_length * varsize ));
             }
@@ -1335,7 +1335,7 @@ static void omf_write_alias( void )
         if ( len1 > MAX_ID_LEN_OMF )
             len1 = MAX_ID_LEN_OMF;
 #endif
-        p = buff;
+        p = (char *)buff;
         *p++ = len1;
         memcpy( p, tmp, len1 );
         p += len1;
@@ -1386,7 +1386,7 @@ static ret_code omf_write_pubdef( void )
         uint_8          curr32;
         uint_8          is32;
 
-        for ( size = 0, data = StringBufferEnd; q; q = q->next ) {
+        for ( size = 0, data = (uint_8 *)StringBufferEnd; q; q = q->next ) {
             unsigned    recsize;
             unsigned    len;
             struct asym *sym;
@@ -1404,7 +1404,7 @@ static ret_code omf_write_pubdef( void )
                     *StringBufferEnd = len;
                     if ( ModuleInfo.case_sensitive == FALSE )
                         _strupr( StringBufferEnd + 1 );
-                    AttachData( &obj, StringBufferEnd, len + 1 );
+                    AttachData( &obj, (uint_8 *)StringBufferEnd, len + 1 );
                     omf_write_record( &obj );
                 } else if ( Parse_Pass == PASS_1 ) {
                     /* ??? */
@@ -1433,13 +1433,13 @@ static ret_code omf_write_pubdef( void )
             /* exit loop if segment or offset magnitude changes, or record becomes too big */
             if( size && ( sym->segment != curr_seg || is32 != curr32 || recsize > MAX_PUB_LENGTH ) )
                 break;
-            len = Mangle( sym, data + 1 );
+            len = Mangle( sym, (char *)data + 1 );
 #if MAX_ID_LEN > MAX_ID_LEN_OMF
             if ( len > 255 )
                 len = 255; /* length is 1 byte only */
 #endif
             if ( ModuleInfo.convert_uppercase )
-                _strupr( data + 1 );
+                _strupr( (char *)data + 1 );
             curr_seg = sym->segment;
             curr32 = is32;
 
@@ -1458,7 +1458,7 @@ static ret_code omf_write_pubdef( void )
         if ( size ) {
             struct omf_rec      obj;
             omf_InitRec( &obj, CMD_PUBDEF );
-            AttachData( &obj, StringBufferEnd, size );
+            AttachData( &obj, (uint_8 *)StringBufferEnd, size );
             obj.is_32 = curr32;
             if( curr_seg == NULL ) { /* absolute symbol, no segment */
                 obj.d.pubdef.base.grp_idx = 0;
@@ -1529,7 +1529,7 @@ static void omf_write_header_dbgcv( void )
     omf_InitRec( &obj, CMD_COMENT );
     obj.d.coment.attr = 0x00;
     obj.d.coment.cmt_class = CMT_MS_OMF; /* MS extensions present */
-    AttachData( &obj, "\001CV", 3 );
+    AttachData( &obj, (uint_8 *)"\001CV", 3 );
     omf_write_record( &obj );
     for ( i = 0; i < DBGS_MAX; i++ ) {
         SymDebSeg[i] = (struct dsym *)CreateIntSegment( SymDebParm[i].name, SymDebParm[i].cname, 0, USE32, TRUE );
@@ -1547,8 +1547,8 @@ static void omf_write_debug_tables( void )
 /****************************************/
 {
     if ( SymDebSeg[DBGS_SYMBOLS] && SymDebSeg[DBGS_TYPES] ) {
-        SymDebSeg[DBGS_SYMBOLS]->e.seginfo->CodeBuffer = CurrSource;
-        SymDebSeg[DBGS_TYPES]->e.seginfo->CodeBuffer = CurrSource + 1024;
+        SymDebSeg[DBGS_SYMBOLS]->e.seginfo->CodeBuffer = (uint_8 *)CurrSource;
+        SymDebSeg[DBGS_TYPES]->e.seginfo->CodeBuffer = (uint_8 *)CurrSource + 1024;
         cv_write_debug_tables( SymDebSeg[DBGS_SYMBOLS], SymDebSeg[DBGS_TYPES], NULL );
     }
 }
diff --git a/segment.c b/segment.c
index 26f7a63f..95a9bb8a 100644
--- a/segment.c
+++ b/segment.c
@@ -1168,7 +1168,7 @@ void SegmentInit( int pass )
 {
     struct dsym *curr;
     uint_32     i;
-    char        *p;
+    uint_8      *p;
     CurrSeg      = NULL;
     stkindex     = 0;
 

From 3dd005d7b4a26a8adce4980961661fd4196492ff Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Sun, 20 Oct 2024 11:30:10 +0200
Subject: [PATCH 08/11] Clang/GCC warnings -Wunused -Wuninitialized

---
 H/cpumodel.h       |  4 ++--
 H/globals.h        |  4 ++--
 Makefile-Linux.mak |  3 ++-
 assemble.c         |  2 ++
 bin.c              | 18 ++++++++-------
 codegenv2.c        |  5 ++--
 coff.c             |  7 +++---
 condasm.c          |  5 +++-
 context.c          |  4 ++--
 cpumodel.c         |  8 +++----
 data.c             | 20 ++++++++--------
 dbgcv.c            | 17 ++++++--------
 directiv.c         |  2 ++
 equate.c           |  1 -
 expans.c           |  2 +-
 expreval.c         | 49 +++++++++++++++++++--------------------
 extern.c           |  2 +-
 hll.c              | 12 ++++++----
 input.c            |  3 +--
 invoke.c           | 13 ++++-------
 label.c            |  2 +-
 listing.c          |  4 ++--
 loop.c             |  2 +-
 macho64.c          |  2 --
 macro.c            |  8 +++----
 parser.c           |  9 ++------
 preproc.c          | 30 ++++++++++++------------
 proc.c             | 57 ++++++++++++++++++++++++----------------------
 pseudoFilter.c     | 10 ++++----
 simd.c             |  2 --
 simsegm.c          |  2 +-
 tokenize.c         |  4 ----
 32 files changed, 151 insertions(+), 162 deletions(-)

diff --git a/H/cpumodel.h b/H/cpumodel.h
index 04ff7e11..35701337 100644
--- a/H/cpumodel.h
+++ b/H/cpumodel.h
@@ -10,7 +10,7 @@
 
 extern ret_code   SetCPU( enum cpu_info );
 extern void       SetModel(void);
-static struct asym *sym_CodeSize; /* numeric. requires model */
-static struct asym *sym_DataSize; /* numeric. requires model */
+extern struct asym *sym_CodeSize; /* numeric. requires model */
+extern struct asym *sym_DataSize; /* numeric. requires model */
 
 #endif
diff --git a/H/globals.h b/H/globals.h
index f0dc2ff4..3a0fe3d2 100644
--- a/H/globals.h
+++ b/H/globals.h
@@ -544,14 +544,14 @@ enum opt_queues {
 };
 
 enum prologue_epilogue_mode {
-    PEM_DEFAULT, /* must be value 0 */
+    PEM_DEFAULT = 0, /* must be value 0 */
     PEM_MACRO,
     PEM_NONE
 };
 
 /* Stack distance */
 enum dist_type {
-    //STACK_NONE,
+    STACK_NONE,
     STACK_NEAR,
     STACK_FAR,
 };
diff --git a/Makefile-Linux.mak b/Makefile-Linux.mak
index 6da1588e..3790abcb 100644
--- a/Makefile-Linux.mak
+++ b/Makefile-Linux.mak
@@ -16,6 +16,8 @@ inc_dirs  = -IH
 
 ifeq ($(DEBUG),0)
 extra_c_flags = -DNDEBUG -O2 -funsigned-char -Werror=write-strings
+extra_c_flags += -Wunused -Wuninitialized
+extra_c_flags += -Wno-switch -Wno-enum-conversion -Wno-enum-compare
 OUTD=GccUnixR
 else
 extra_c_flags = -DDEBUG_OUT -g
@@ -27,7 +29,6 @@ CC = gcc
 extra_c_flags += -Wno-discarded-qualifiers
 else
 CC = clang
-extra_c_flags += -Wno-switch -Wno-enum-conversion -Wno-enum-compare
 endif
 
 c_flags =-D __UNIX__ $(extra_c_flags)
diff --git a/assemble.c b/assemble.c
index d6c1173c..35f21cc3 100644
--- a/assemble.c
+++ b/assemble.c
@@ -177,6 +177,7 @@ static const enum seg_type stt[] = {
     SEGTYPE_CODE, SEGTYPE_DATA, SEGTYPE_DATA, SEGTYPE_BSS
 };
 
+/*
 static void CheckBOM(FILE *f)
 {
 	unsigned long bom;
@@ -184,6 +185,7 @@ static void CheckBOM(FILE *f)
 	if ((bom & 0xFFFFFF) != 0xBFBBEF)
 		rewind(f);
 }
+*/
 
 extern void RewindToWin64() 
 {
diff --git a/bin.c b/bin.c
index e246de9d..94fc673f 100644
--- a/bin.c
+++ b/bin.c
@@ -434,7 +434,7 @@ static ret_code DoFixup( struct dsym *curr, struct calc_param *cp )
     struct dsym *seg;
     uint_32 value;
 #if PE_SUPPORT && AMD64_SUPPORT
-    uint_64 value64;
+    uint_64 value64 = 0;
 #endif
     uint_32 offset;  /* v2.07 */
     struct fixup *fixup;
@@ -1245,9 +1245,9 @@ static void pe_set_values( struct calc_param *cp )
     struct dsym *pehdr;
     struct dsym *objtab;
     struct dsym *reloc = NULL;
-    struct IMAGE_PE_HEADER32 *ph32;
+    struct IMAGE_PE_HEADER32 *ph32 = NULL;
 #if AMD64_SUPPORT
-    struct IMAGE_PE_HEADER64 *ph64;
+    struct IMAGE_PE_HEADER64 *ph64 = NULL;
 #endif
     struct IMAGE_FILE_HEADER *fh;
     struct IMAGE_SECTION_HEADER *section;
@@ -1516,16 +1516,15 @@ static ret_code bin_write_module( struct module_info *modinfo )
     uint_32 sizetotal;
     int i;
     int first;
-    uint_32 sizeheap;
+    uint_32 sizeheap = 0;
 #if MZ_SUPPORT
     struct IMAGE_DOS_HEADER *pMZ;
-    uint_16 reloccnt;
+    uint_16 reloccnt = 0;
     uint_32 sizemem;
     struct dsym *stack = NULL;
-    uint_8  *hdrbuf;
+    uint_8  *hdrbuf = NULL;
 #endif
     struct calc_param cp = { TRUE, 0 };
-	uint_32 origsize;
 	uint_32 writesize;
 	uint_8 *codeptr;
 
@@ -1554,10 +1553,12 @@ static ret_code bin_write_module( struct module_info *modinfo )
     }
     cp.fileoffset = cp.sizehdr;
 
+#if MZ_SUPPORT
     if ( cp.sizehdr ) {
         hdrbuf = LclAlloc( cp.sizehdr );
         memset( hdrbuf, 0, cp.sizehdr );
     }
+#endif
     cp.entryoffset = -1;
 
     /* set starting offsets for all sections */
@@ -1704,6 +1705,7 @@ static ret_code bin_write_module( struct module_info *modinfo )
     }
 #endif
 
+#if MZ_SUPPORT
     if ( cp.sizehdr ) {
         if ( fwrite( hdrbuf, 1, cp.sizehdr, CurrFile[OBJ] ) != cp.sizehdr )
             WriteError();
@@ -1713,6 +1715,7 @@ static ret_code bin_write_module( struct module_info *modinfo )
 #endif
         LclFree( hdrbuf );
     }
+#endif
 
 #ifdef DEBUG_OUT
     for( curr = SymTables[TAB_SEG].head; curr; curr = curr->next ) {
@@ -1772,7 +1775,6 @@ static ret_code bin_write_module( struct module_info *modinfo )
 			if (ModuleInfo.flat)
 			{
 				/* For flat type we have to write out one byte at a time and verify it against the org fixup list */
-				origsize = size;
 				codeptr = curr->e.seginfo->CodeBuffer;
 				while (codeptr < (curr->e.seginfo->CodeBuffer+size))
 				{
diff --git a/codegenv2.c b/codegenv2.c
index 36e3710a..a1f14f3f 100644
--- a/codegenv2.c
+++ b/codegenv2.c
@@ -1233,7 +1233,6 @@ int BuildMemoryEncoding(unsigned char* pmodRM, unsigned char* pSIB, unsigned cha
 	unsigned char   idxRegNo = 17;
 	int             baseRegSize = 0;
 	int             idxRegSize = 0;
-	int             symSize = 0;
 	bool			skipSIB = FALSE;
 
 	/* Absolute addressing modes can skip this */
@@ -1289,7 +1288,7 @@ int BuildMemoryEncoding(unsigned char* pmodRM, unsigned char* pSIB, unsigned cha
 	/* If the memory address refers to a symbol indirectly.. */
 	if (opExpr[instr->memOpnd].sym && opExpr[instr->memOpnd].kind == EXPR_ADDR)
 	{
-		symSize = SizeFromMemtype(opExpr[instr->memOpnd].mem_type, ModuleInfo.Ofssize, opExpr[instr->memOpnd].sym);
+		SizeFromMemtype(opExpr[instr->memOpnd].mem_type, ModuleInfo.Ofssize, opExpr[instr->memOpnd].sym);
 
 		/* For 64bit mode, all symbol references are RIP relative, unless the symbol is on the stack.
 		   EXCEPT, if the memory address includes a register. */
@@ -2005,7 +2004,7 @@ ret_code CodeGenV2(const char* instr, struct code_info* CodeInfo, uint_32 oldofs
 		}
 
 	}
-skip:
+
 	/* Write out listing. */
 	if (retcode == NOT_ERROR)
 	{
diff --git a/coff.c b/coff.c
index 2de90182..134ffa28 100644
--- a/coff.c
+++ b/coff.c
@@ -52,6 +52,7 @@ static const char* const SymDebName[DBGS_MAX] = { ".debug$S", ".debug$T" };
 
 static const char szdrectve[] = { ".drectve" };
 
+/*
 static const IMAGE_SYMBOL isFeat00 = {
     {"@feat.00"},
      1,
@@ -60,6 +61,8 @@ static const IMAGE_SYMBOL isFeat00 = {
      IMAGE_SYM_CLASS_STATIC,
      0
 };
+*/
+
 #if COMPID
 static const IMAGE_SYMBOL isCompId = {
     {"@comp.id"},
@@ -398,7 +401,6 @@ static uint_32 coff_write_symbols( struct module_info *modinfo, struct coffmod *
     int         type;
     int         storageclass;
     int         aux;
-    int         count;
 
 #if COMPID
     /* write "@comp.id" entry */
@@ -694,9 +696,8 @@ static uint_32 SetSymbolIndices( struct module_info *ModuleInfo, struct coffmod
     struct asym  *sym;
     uint_32 index;
     uint_32 i;
-    struct asym *lastfproc;
+    struct asym *lastfproc = NULL;
     unsigned lastfile = 0;
-    int section;
 
     index = 0;
     cm->lastproc = NULL;
diff --git a/condasm.c b/condasm.c
index 63e9ce4c..a16d5481 100644
--- a/condasm.c
+++ b/condasm.c
@@ -222,7 +222,7 @@ ret_code CondAsmDirective( int i, struct asm_tok tokenarray[] )
     int directive = tokenarray[i].tokval;
     const char *string1;
     const char *string2;
-    enum if_state NextIfState;
+    enum if_state NextIfState = BLOCK_DONE;
     struct expr opndx;
 
     if ( CurrIfState != BLOCK_ACTIVE ) {
@@ -417,6 +417,9 @@ ret_code CondAsmDirective( int i, struct asm_tok tokenarray[] )
         return( EmitErr( SYNTAX_ERROR_EX, tokenarray[i].string_ptr ) );
     }
 escape:
+    if ( NextIfState == BLOCK_DONE ) {
+        return( ERROR );
+    }
     CurrIfState = NextIfState;
 
     DebugMsg1(("CondAsmDirective(%s) exit, state=%s, lvl=%u, falselvl=%u\n",
diff --git a/context.c b/context.c
index 21367900..169df2ab 100644
--- a/context.c
+++ b/context.c
@@ -107,7 +107,7 @@ ret_code ContextDirective( int i, struct asm_tok tokenarray[] )
 {
     int start = i;
     int directive = tokenarray[i].tokval;
-    enum context_type type;
+    enum context_type type = -1;
     int j;
     struct context *curr;
 
@@ -116,7 +116,7 @@ ret_code ContextDirective( int i, struct asm_tok tokenarray[] )
     i++; /* skip CONTEXT keyword */
 
     while ( tokenarray[i].token == T_ID ) {
-        for ( j = 0, type = -1; j < ( sizeof(typetab) / sizeof(typetab[0]) ); j++ ) {
+        for ( j = 0; j < ( sizeof(typetab) / sizeof(typetab[0]) ); j++ ) {
             if ( _stricmp( contextnames[j], tokenarray[i].string_ptr ) == 0 ) {
                 type = typetab[j];
                 break;
diff --git a/cpumodel.c b/cpumodel.c
index a8139bf4..75e27111 100644
--- a/cpumodel.c
+++ b/cpumodel.c
@@ -67,8 +67,8 @@ static const struct typeinfo ModelAttrValue[] = {
     { OPSYS_OS2,      INIT_OS         },
 };
 
-static struct asym *sym_CodeSize  ; /* numeric. requires model */
-static struct asym *sym_DataSize  ; /* numeric. requires model */
+struct asym *sym_CodeSize  ; /* numeric. requires model */
+struct asym *sym_DataSize  ; /* numeric. requires model */
 static struct asym *sym_Model     ; /* numeric. requires model */
 struct asym *sym_Interface ; /* numeric. requires model */
 struct asym *sym_Cpu       ; /* numeric. This is ALWAYS set */
@@ -247,8 +247,8 @@ ret_code ModelDirective( int i, struct asm_tok tokenarray[] )
 {
     enum model_type model;
     enum lang_type language;
-    enum dist_type distance;
-    enum os_type ostype;
+    enum dist_type distance = STACK_NONE;
+    enum os_type ostype = OPSYS_DOS;
     int index;
     uint_8 init;
     uint_8 initv;
diff --git a/data.c b/data.c
index e8b941b6..2cb851fd 100644
--- a/data.c
+++ b/data.c
@@ -555,7 +555,7 @@ static ret_code data_item( int *start_pos, struct asm_tok tokenarray[], struct a
     //unsigned int        count;
     uint_8              *pchar,*p;
     char                tmp;
-    enum fixup_types    fixup_type;
+    enum fixup_types    fixup_type = FIX_VOID;
     struct fixup        *fixup;
     struct expr         opndx;
     uint_16 buff[256];
@@ -1290,8 +1290,8 @@ ret_code data_dir( int i, struct asm_tok tokenarray[], struct asym *type_sym )
 {
     uint_32             no_of_bytes;
     struct asym         *sym = NULL;
-    uint_32             old_offset;
-    uint_32             currofs; /* for LST output */
+    uint_32             old_offset = 0;
+    uint_32             currofs = 0; /* for LST output */
     enum memtype        mem_type;
     bool                is_float = FALSE;
     int                 idx;
@@ -1302,9 +1302,8 @@ ret_code data_dir( int i, struct asm_tok tokenarray[], struct asym *type_sym )
 	struct sfield   *f2;
 	struct sfield   *fPrev;
 	bool foundSubType = FALSE;
-	uint_32 subid = 0;
-	uint_32 subcnt = 0;
-	uint_32 k = 0;
+	//uint_32 subid = 0;
+	//uint_32 subcnt = 0;
 
     /* v2.05: the previous test in parser.c wasn't fool-proofed */
     if ( i > 1 && ModuleInfo.m510 == FALSE ) {
@@ -1514,19 +1513,18 @@ ret_code data_dir( int i, struct asm_tok tokenarray[], struct asym *type_sym )
 		// Check sub type.
 		symtype = ((struct dsym *)type_sym);
 		foundSubType = FALSE;
-		subid = 0;
-		subcnt = 0;
-		k = 0;
+		//subid = 0;
+		//subcnt = 0;
 		for (f = symtype->e.structinfo->head; f != NULL; f = f->next) 
 		{
 			if (strcmp(tokenarray[i].string_ptr, f->sym.name) == 0)
 			{
 				f2 = f;
 				foundSubType = TRUE;
-				subid = subcnt;
+				//subid = subcnt;
 				fPrev = symtype->e.structinfo->head;
 			}
-			subcnt++;
+			//subcnt++;
 		}
 		if (!foundSubType)
 		{
diff --git a/dbgcv.c b/dbgcv.c
index 0255d3b0..6e0abcae 100644
--- a/dbgcv.c
+++ b/dbgcv.c
@@ -552,8 +552,8 @@ static void cv_write_type_procedure(struct dbgcv* cv, struct asym* sym, int cnt)
 	int size = sizeof(CV_PROCEDURE);
 	int leaf = LF_PROCEDURE;
 	int type = sizeof(CV_typ_t);
-	CV_typ_t* p_32;
-	CV_typ16_t* p_16;
+	CV_typ_t* p_32 = NULL;
+	CV_typ16_t* p_16 = NULL;
 	struct dsym* param;
 
 	if (Options.debug_symbols == CV_SIGNATURE_C7) {
@@ -626,10 +626,10 @@ static void cv_write_type_procedure(struct dbgcv* cv, struct asym* sym, int cnt)
 static void cv_write_type(struct dbgcv* cv, struct asym* sym)
 {
 	struct dsym* type = (struct dsym*)sym;
-	uint_8* tmp;
+	uint_8* tmp = NULL;
 	int		namesize;
 	int		typelen;
-	int		size;
+	int		size = 0;
 	int		leaf;
 	CV_prop_t	property;
 	struct cv_counters count;
@@ -816,16 +816,17 @@ static void cv_write_symbol(struct dbgcv* cv, struct asym* sym)
 	enum fixup_types rlctype;
 	uint_8	Ofssize;
 	struct fixup* fixup;
-	struct dsym* proc;
+	struct dsym* proc = NULL;
 	struct dsym* lcl;
 	int		i, j, k;
 	int		cnt[2];
 	struct	dsym* locals[2];
-	struct	dsym* q;
+	struct	dsym* q = NULL;
 	int		size;
 	int		leaf;
 	uint_16	typeref;
 
+	j = 0;
 	Ofssize = GetSymOfssize(sym);
 	len = GetCVStructLen(sym, Ofssize);
 	cv->ps = checkflush(cv->symbols, cv->ps, 1 + sym->name_size + len, cv->param);
@@ -1467,7 +1468,6 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 
 				while (Queue) {
 					CV_Line_t* Line;
-					CV_Line_t* Prev;
 					int fileStart = Queue->srcfile;
 
 					if (Queue->number == 0)
@@ -1475,7 +1475,6 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 
 					File->offFile = cv.files[fileStart].offset;
 					File->cbBlock = 12;
-					Prev = NULL;
 
 					int fileCur = fileStart;
 
@@ -1520,7 +1519,6 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 								File->offFile = cv.files[Queue->srcfile].offset;
 								File->cbBlock = 12;
 								File->nLines = 0;
-								Prev = NULL;
 							}
 							fileCur = Queue->srcfile;
 							linenum = Queue->number;
@@ -1545,7 +1543,6 @@ void cv_write_debug_tables(struct dsym* symbols, struct dsym* types, void* pv)
 						Line->linenumStart = linenum;
 						Line->deltaLineEnd = 0;
 						Line->fStatement = 1;
-						Prev = Line;
 					}
 
 					/* Finalize last line queue record*/
diff --git a/directiv.c b/directiv.c
index e2ab5ed8..52dd1504 100644
--- a/directiv.c
+++ b/directiv.c
@@ -258,6 +258,7 @@ ret_code IncBinDirective( int i, struct asm_tok tokenarray[] )
         omf_OutSelect( TRUE );
 
     DebugMsg1(("IncBinDirective: filename=%s, offset=%" I32_SPEC "u, size=%" I32_SPEC "u\n", StringBufferEnd, fileoffset, sizemax ));
+    (void)sizemax;
 
     /* try to open the file */
     if ( (file = SearchFile( StringBufferEnd, FALSE )) != NULL ) 
@@ -270,6 +271,7 @@ ret_code IncBinDirective( int i, struct asm_tok tokenarray[] )
 		if ( fileoffset )
 			fseek( file, fileoffset, SEEK_SET );  /* fixme: use fseek64() */
 		result = fread(pBinData, sz, 1, file);
+		(void)result;
 		OutputBinBytes(pBinData, sz);
 
         /* transfer file content to the current segment. */
diff --git a/equate.c b/equate.c
index fbdc6908..4a82ee3b 100644
--- a/equate.c
+++ b/equate.c
@@ -360,7 +360,6 @@ struct asym *CreateConstant( struct asm_tok tokenarray[] )
 	struct asm_tok      tokenarray2[32];
     const char          *name = tokenarray[0].string_ptr;
     int                 i = 2;
-	int                 j;
     ret_code            rc;
     char                *p;
     bool                cmpvalue = FALSE;
diff --git a/expans.c b/expans.c
index 915a6b23..2a2e44c3 100644
--- a/expans.c
+++ b/expans.c
@@ -175,7 +175,7 @@ static void SkipMacro( struct asm_tok tokenarray[] )
 int RunMacro( struct dsym *macro, int idx, struct asm_tok tokenarray[], char *out, int mflags, bool *is_exitm )
 /*************************************************************************************************************/
 {
-    char        *currparm;
+    char        *currparm = NULL;
     char        *savedStringBuffer = StringBufferEnd;
     int         i;
     //int         start = idx-1;
diff --git a/expreval.c b/expreval.c
index 67b29b7d..1aa160dc 100644
--- a/expreval.c
+++ b/expreval.c
@@ -129,7 +129,7 @@ static ret_code  GetMask128(struct expr *opnd1, int index, struct asm_tok tokena
     char            buffer1[MAX_LINE_LEN];
     char            buff[18];
     char            *ptr;
-    int             i= Token_Count; /* i must remain the start index */
+    //int             i= Token_Count; /* i must remain the start index */
 
 
       strcpy( buffer,tokenarray->tokpos); 
@@ -241,12 +241,10 @@ static ret_code  GetMask128(struct expr *opnd1, int index, struct asm_tok tokena
 static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok tokenarray[], const struct dsym *symtype )
 /****************************************************************************************************************************/
 {
-    char            *ptr, *ptr2, *ptr3;
+    char            *ptr;
     struct sfield   *f;
     int_32          nextofs;
     int             i;
-    int             nlabel;
-    struct asym    *sym = NULL;
     struct          asym *lbl = NULL;
 #if AMD64_SUPPORT
     uint_64         dst128Hi;
@@ -257,7 +255,7 @@ static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok to
 #else
     uint_32         dwRecInit;
 #endif
-    bool            is_record_set;
+    //bool            is_record_set;
     struct expr     opndx;
     char            buffer[MAX_LINE_LEN];
     char            buffer1[MAX_LINE_LEN];
@@ -284,7 +282,7 @@ static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok to
         dwRecInit = 0;
         dst128Hi = 0; /* clear Hi 64 bit for the 128 bit RECORD */
         dst128Lo = 0; /* clear Lo 64 bit for the 128 bit RECORD */
-        is_record_set = FALSE;
+        //is_record_set = FALSE;
     }
 
     /* scan the RECORD's members */
@@ -305,7 +303,7 @@ static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok to
                     int j = Token_Count + 1;
                     int max_item = Tokenize( f->ivalue, j, tokenarray, TOK_RESCAN );
                     EvalOperand( &j, tokenarray, max_item, &opndx, 0 );
-                    is_record_set = TRUE;
+                    //is_record_set = TRUE;
                 } else {
                     opndx.value = 0;
                     opndx.kind = EXPR_CONST;
@@ -313,7 +311,7 @@ static ret_code  InitRecordVar( struct expr *opnd1, int index, struct asm_tok to
                 }
             } else {
                 EvalOperand( &i, tokenarray, Token_Count, &opndx, 0 );
-                is_record_set = TRUE;
+                //is_record_set = TRUE;
             }
             if ( opndx.kind != EXPR_CONST || opndx.quoted_string != NULL )
                 EmitError( CONSTANT_EXPECTED );
@@ -863,6 +861,8 @@ static ret_code get_operand( struct expr *opnd, int *idx, struct asm_tok tokenar
 	struct asym *labelsym2;
 	struct asm_tok tok;
 
+    memset( &tok, 0, sizeof(struct asm_tok) );
+
     DebugMsg1(("%u get_operand(idx=%u >%s<) enter [memtype=%Xh]\n", evallvl, i, tokenarray[i].tokpos, opnd->mem_type ));
     switch( tokenarray[i].token ) {
 	case T_DOT:
@@ -873,6 +873,7 @@ static ret_code get_operand( struct expr *opnd, int *idx, struct asm_tok tokenar
 			sprintf(clabel, "%s%s", ".", tokenarray[(*idx) + 1].string_ptr);
 			labelsym = SymFind(clabel);
 			labelsym2 = SymFind(tokenarray[(*idx) + 1].string_ptr);
+			(void)labelsym2;
 
 			if ((*idx) > 0)
 			{
@@ -886,10 +887,9 @@ static ret_code get_operand( struct expr *opnd, int *idx, struct asm_tok tokenar
 				strcpy(clabel, tokenarray[(*idx)].string_ptr);
 				sprintf(tokenarray[(*idx)].string_ptr, "%s%s", ".", clabel);
 			}
-			else if (labelsym == NULL && labelsym2 == NULL)
-			{
-
-			}
+			//else if (labelsym == NULL && labelsym2 == NULL)
+			//{
+			//}
 			i++;
 			goto isNowID;
 		}
@@ -2143,7 +2143,7 @@ handles ARGSIZE operator.
 */
 static ret_code argsize_op(int oper, struct expr *opnd1, struct expr *opnd2, struct asym *sym, char *name)
 {
-	int argNo = 1;
+	//int argNo = 1;
 	bool argFound = FALSE;
 	struct dsym* param = NULL;
 
@@ -2178,7 +2178,7 @@ static ret_code argsize_op(int oper, struct expr *opnd1, struct expr *opnd2, str
 			argFound = TRUE;
 			break;
 		}
-		argNo++;
+		//argNo++;
 		param = param->nextparam;
 	}
 
@@ -2206,7 +2206,7 @@ handles ARGTYPE operator.
 */
 static ret_code argtype_op(int oper, struct expr *opnd1, struct expr *opnd2, struct asym *sym, char *name)
 {
-	int argNo = 1;
+	//int argNo = 1;
 	bool argFound = FALSE;
 	struct dsym* param = NULL;
 
@@ -2241,7 +2241,7 @@ static ret_code argtype_op(int oper, struct expr *opnd1, struct expr *opnd2, str
 			argFound = TRUE;
 			break;
 		}
-		argNo++;
+		//argNo++;
 		param = param->nextparam;
 	}
 
@@ -3311,8 +3311,8 @@ static ret_code check_streg( struct expr *opnd1, struct expr *opnd2 )
 static void cmp_types( struct expr *opnd1, struct expr *opnd2, int trueval )
 /**************************************************************************/
 {
-    struct asym *type1;
-    struct asym *type2;
+    struct asym *type1 = NULL;
+    struct asym *type2 = NULL;
 
     /* v2.10: special handling of pointer types. */
     //if ( opnd1->mem_type == MT_PTR && opnd2->mem_type == MT_PTR && opnd1->type && opnd2->type ) {
@@ -4042,14 +4042,15 @@ static ret_code evaluate( struct expr *opnd1, int *i, struct asm_tok tokenarray[
 /********************************************************************************************************************/
 {
     ret_code rc = NOT_ERROR;
-    char *p;
     char *p1;
 	char clabel[100];
 	struct asym *labelsym;
 	struct asym *labelsym2;
 	struct asm_tok tok;
     struct dsym *recordsym;
-    
+
+    memset( &tok, 0, sizeof(struct asm_tok) );
+
     DebugMsg1(("%u evaluate(i=%d, end=%d, flags=%X) enter [opnd1: kind=%d type=%s]\n",
                ++evallvl, *i, end, flags, opnd1->kind, opnd1->type ? opnd1->type->name : "NULL" ));
 
@@ -4082,10 +4083,9 @@ static ret_code evaluate( struct expr *opnd1, int *i, struct asm_tok tokenarray[
 			strcpy(clabel, tokenarray[(*i)].string_ptr);
 			sprintf(tokenarray[(*i)].string_ptr, "%s%s", ".", clabel);
 		}
-		else if (labelsym == NULL && labelsym2 == NULL)
-		{
-			
-		} 
+		//else if (labelsym == NULL && labelsym2 == NULL)
+		//{
+        //} 
 	}
 	if ((tokenarray[*i].tokval == T_SHORT || tokenarray[*i].tokval == T_OFFSET) && tokenarray[(*i) + 1].token == T_DOT && tokenarray[(*i) + 2].token == T_ID)
 	{
@@ -4128,7 +4128,6 @@ static ret_code evaluate( struct expr *opnd1, int *i, struct asm_tok tokenarray[
 
         int curr_operator;
         struct expr opnd2;
-        struct expr opnd3;
         curr_operator = *i;
         DebugMsg1(("%u evaluate loop, operator=>%s< opnd1->sym=%X, type=%s\n",
                    evallvl, tokenarray[curr_operator].string_ptr, opnd1->sym, (opnd1->type ? opnd1->type->name : "NULL") ));
diff --git a/extern.c b/extern.c
index 508c4874..7e9ebd66 100644
--- a/extern.c
+++ b/extern.c
@@ -893,7 +893,7 @@ ret_code PublicDirective( int i, struct asm_tok tokenarray[] )
     char                *token;
     struct asym         *sym;
     //struct dsym       *dir;
-    char                skipitem;
+    char                skipitem = FALSE;
     enum lang_type      langtype;
 
     DebugMsg1(("PublicDirective(%u) enter\n", i));
diff --git a/hll.c b/hll.c
index 1e20b458..f7cbff77 100644
--- a/hll.c
+++ b/hll.c
@@ -199,9 +199,8 @@ static const char neg_cjmptype[] = { 0, 1, 0, 0, 1, 1 };
 /* in Masm, there's a nesting level limit of 20. In Uasm, there's
 * currently no limit.
 */
-#ifdef __WATCOMC__
-static _inline char HexDigit(char x)
-#elif defined(_MSC_VER)
+/*
+#if defined(_MSC_VER) || defined(__WATCOMC__)
 static _inline char HexDigit(char x)
 #else
 static char HexDigit(char x)
@@ -210,6 +209,7 @@ static char HexDigit(char x)
     x &= 0xF;
     return((x > 9) ? (x - 10 + 'A') : (x + '0'));
 }
+*/
 
 #ifdef DEBUG_OUT
 static unsigned evallvl;
@@ -457,6 +457,7 @@ static char* RenderSimdInstr(char* dst, const char* instr, int start1, int end1,
 }
 
 /* render a Simd instruction using a temporary float immediate macro FP4/FP8 */
+#if 0
 static char* RenderSimdInstrTM(char* dst, const char* instr, int start1, int end1, int start2, int end2, struct asm_tok tokenarray[], enum c_bop op, bool isDouble)
 /*******************************************************************************************************************************/
 {
@@ -502,6 +503,7 @@ static char* RenderSimdInstrTM(char* dst, const char* instr, int start1, int end
     DebugMsg1(("%u RenderInstr(%s)=>%s<\n", evallvl, instr, old));
     return(dst);
 }
+#endif
 
 static char* GetLabelStr(int_32 label, char* buff)
 /**************************************************/
@@ -1832,9 +1834,9 @@ ret_code HllEndDir(int i, struct asm_tok tokenarray[])
     int                 cmd = tokenarray[i].tokval;
     int                 j, n;
 #if AMD64_SUPPORT
-    __int64             temp;
+    __int64             temp = 0;
 #else
-    int                 temp;
+    int                 temp = 0;
 #endif
     int                 acnt = 0;
     int                 bcnt = 0;
diff --git a/input.c b/input.c
index 2104081e..ae8b810b 100644
--- a/input.c
+++ b/input.c
@@ -586,7 +586,6 @@ FILE *SearchFile( const char *path, bool queue )
 {
     FILE        *file = NULL;
     struct src_item *fl;
-    const char  *fn;
     bool        isabs;
     char        fullpath[FILENAME_MAX];
 
@@ -594,7 +593,7 @@ FILE *SearchFile( const char *path, bool queue )
 
     //_splitpath( path, drive, dir, fname, ext );
     //DebugMsg1(("SearchFile(): drive=%s, dir=%s, fname=%s, ext=%s\n", drive, dir, fname, ext ));
-    fn = GetFNamePart( path );
+    GetFNamePart( path );
 
     /* if no absolute path is given, then search in the directory
      * of the current source file first!
diff --git a/invoke.c b/invoke.c
index 3ce8523e..c2c4bbf2 100644
--- a/invoke.c
+++ b/invoke.c
@@ -488,7 +488,7 @@ static int ms64_param(struct dsym const *proc, int index, struct dsym *param, bo
 {
 	uint_32 size;
 	uint_32 psize;
-	int reg;
+	int reg = 0;
 	int reg2;
 	int i;
 	int j = 0;
@@ -2031,7 +2031,7 @@ static int sysv_param(struct dsym const *proc, int index, struct dsym *param, bo
 /************************************************************************************************************************************************/
 {
 	uint_32 psize;
-	int reg;
+	int reg = 0;
 	int reg2;
 	int i;
 	int base;
@@ -3242,7 +3242,6 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 
 	struct asym *lbl = NULL;
 	struct dsym *curseg;
-	struct dsym *prev;
 	struct dsym *currs;
 	size_t slen;
 	char *pSrc;
@@ -3277,9 +3276,8 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 				// Preserve current Segment.
 				curseg = ModuleInfo.currseg;
 				// Find Data Segment.
-				prev = NULL;
 				currs = NULL;
-				for (currs = SymTables[TAB_SEG].head; currs && currs->next; prev = currs, currs = currs->next)
+				for (currs = SymTables[TAB_SEG].head; currs && currs->next; currs = currs->next)
 				{
 					if (strcmp(currs->sym.name, "_DATA") == 0)
 						break;
@@ -3353,9 +3351,8 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 				// Preserve current Segment.
 				curseg = ModuleInfo.currseg;
 				// Find Data Segment.
-				prev = NULL;
 				currs = NULL;
-				for (currs = SymTables[TAB_SEG].head; currs && currs->next; prev = currs, currs = currs->next)
+				for (currs = SymTables[TAB_SEG].head; currs && currs->next; currs = currs->next)
 				{
 					if (strcmp(currs->sym.name, "_DATA") == 0)
 						break;
@@ -4292,7 +4289,7 @@ ret_code InvokeDirective(int i, struct asm_tok tokenarray[])
 	int            size;
 	int            parmpos;
 	int            namepos;
-	int            porder;
+	int            porder = 0;
 	int            j;
 	uint_8         r0flags = 0;
 	struct proc_info *info;
diff --git a/label.c b/label.c
index d2ef660c..2468e7d2 100644
--- a/label.c
+++ b/label.c
@@ -76,7 +76,7 @@ struct asym *CreateLabel( const char *name, enum memtype mem_type, struct qualif
 /*********************************************************************************************************/
 {
     struct asym         *sym;
-    uint_32             addr;
+    uint_32             addr = 0;
     char                buffer[20];
 
     DebugMsg1(("CreateLabel(%s, memtype=%Xh, %" I32_SPEC "Xh, %u) enter\n", name, mem_type, ti, bLocal));
diff --git a/listing.c b/listing.c
index e38abf6f..d110bc2e 100644
--- a/listing.c
+++ b/listing.c
@@ -1053,7 +1053,7 @@ void LstWriteCRef( void )
 {
     struct asym     **syms;
     struct dsym     *dir;
-    struct struct_info *si;
+    //struct struct_info *si;
     int             idx;
     uint_32         i;
     uint_32         SymCount;
@@ -1082,7 +1082,7 @@ void LstWriteCRef( void )
             continue;
         switch (syms[i]->state) {
         case SYM_TYPE:
-            si = ((struct dsym *)syms[i])->e.structinfo;
+            //si = ((struct dsym *)syms[i])->e.structinfo;
             switch ( syms[i]->typekind ) {
             case TYPE_RECORD:  idx = LQ_RECORDS; break;
             case TYPE_TYPEDEF: idx = LQ_TYPEDEFS;break;
diff --git a/loop.c b/loop.c
index 3c7e5daa..c992f7c7 100644
--- a/loop.c
+++ b/loop.c
@@ -28,7 +28,7 @@ ret_code LoopDirective( int i, struct asm_tok tokenarray[] )
     int arg_loc;
     int len;
     //int skipcomma;
-    char *parmstring;
+    char *parmstring = NULL;
     char *ptr;
     struct dsym *macro;
     bool is_exitm;
diff --git a/macho64.c b/macho64.c
index 6788b8f0..dbd6a13c 100644
--- a/macho64.c
+++ b/macho64.c
@@ -385,7 +385,6 @@ Create all the macho obj file structures and calculate offsets.
 ========================================================================================== */
 static void macho_build_structures( struct module_info *modinfo, struct macho_module mm )
 {
-	int cnt = 0;
 	struct dsym *curr;
 	struct dsym *seg = NULL;
 	struct macho_section_entry *currSec;
@@ -703,7 +702,6 @@ static void macho_build_structures( struct module_info *modinfo, struct macho_mo
 static ret_code macho_write_module( struct module_info *modinfo )
 {
 	struct macho_module mm;
-	int fileofs = 0;
 
 	DebugMsg(("macho_write_module: enter\n"));
 
diff --git a/macro.c b/macro.c
index bbd79653..fcddc943 100644
--- a/macro.c
+++ b/macro.c
@@ -289,7 +289,7 @@ ret_code StoreMacro( struct dsym *macro, int i, struct asm_tok tokenarray[], boo
     struct macro_info   *info;
     char                *src;
     char                *token;
-    int                 mindex;
+    int                 mindex = 0;
     struct mparm_list   *paranode;
     struct srcline      **nextline;
 #ifdef DEBUG_OUT
@@ -318,7 +318,7 @@ ret_code StoreMacro( struct dsym *macro, int i, struct asm_tok tokenarray[], boo
             info->parmlist = NULL;
         }
 
-        for( paranode = info->parmlist, mindex = 0; i < Token_Count ; paranode++ ) {
+        for( paranode = info->parmlist; i < Token_Count ; paranode++ ) {
 
             token = tokenarray[i].string_ptr;
             /* Masm accepts reserved words and instructions as parameter
@@ -608,7 +608,7 @@ ret_code StoreAutoMacro(struct dsym *macro, int i, struct asm_tok tokenarray[],
 	struct macro_info   *info;
 	char                *src;
 	char                *token;
-	int                 mindex;
+	int                 mindex = 0;
 	struct mparm_list   *paranode;
 	struct srcline      **nextline;
 #ifdef DEBUG_OUT
@@ -640,7 +640,7 @@ ret_code StoreAutoMacro(struct dsym *macro, int i, struct asm_tok tokenarray[],
 			info->parmlist = NULL;
 		}
 
-		for (paranode = info->parmlist, mindex = 0; i < Token_Count; paranode++) {
+		for (paranode = info->parmlist; i < Token_Count; paranode++) {
 
 			token = tokenarray[i].string_ptr;
 			/* Masm accepts reserved words and instructions as parameter
diff --git a/parser.c b/parser.c
index 17a737c9..a6707686 100644
--- a/parser.c
+++ b/parser.c
@@ -3070,18 +3070,14 @@ ret_code ParseLine(struct asm_tok tokenarray[]) {
 	int                j;
 	unsigned           dirflags;
 	unsigned           CurrOpnd;
-	ret_code           temp;
+	ret_code           temp = ERROR;
 	struct asym        *sym;
-	uint_32            oldofs;
+	uint_32            oldofs = 0;
 	enum special_token regtok;
-	int                c0;
-	int                c1;
 	unsigned           flags;
-	char               *pnlbl;
 	int                alignCheck = 16;
 	int                infSize    = 0;
 	int                oldi       = 0;
-	struct dsym        *recsym    = 0;
 	struct code_info   CodeInfo;
 	struct expr        opndx[MAX_OPND + 1];
 	// We create copies of these structures for now as the old codegen has a very ugly way of working with additional vex 3 opnd forms, by
@@ -3091,7 +3087,6 @@ ret_code ParseLine(struct asm_tok tokenarray[]) {
 	struct expr        opndxV2[MAX_OPND + 1];
 	const char         *opcodePtr = NULL;
 	int                opndCount  = 0;
-	char               *instr     = NULL;
     bool               doDataInProc = FALSE;
 
 	memset(&opndx, 0, sizeof(opndx));
diff --git a/preproc.c b/preproc.c
index b3e870a2..9ae57637 100644
--- a/preproc.c
+++ b/preproc.c
@@ -71,7 +71,6 @@ ret_code WriteCodeLabel( char *line, struct asm_tok tokenarray[] )
 */
 int VerifyBrackets(struct asm_tok tokenarray[], int openIdx, bool inParam)
 {
-	int len;
 	int i = openIdx;
 	int opCnt = 0;
 	if (tokenarray[i].token != T_OP_BRACKET)
@@ -159,9 +158,9 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 	char *pStr = newline;
 	char *pType = NULL;
 	bool inExpr = FALSE;
-	bool hasExprBracket = FALSE;
+	//bool hasExprBracket = FALSE;
 	bool inParam = FALSE;
-	bool inProc = FALSE;
+	//bool inProc = FALSE;
 	int firstDeRefIdx = 0;
 	int paramCount = 0;
 	char pcs[16];
@@ -197,10 +196,10 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 						if (tokenarray[j].token == T_DIRECTIVE && (tokenarray[j].dirtype == DRT_HLLSTART || tokenarray[j].dirtype == DRT_HLLEND))
 						{
 							inExpr = TRUE;
-							if (tokenarray[j + 1].token == T_OP_BRACKET || tokenarray[j + 1].tokval == '(')
-								hasExprBracket = TRUE;
-							else
-								hasExprBracket = FALSE;
+							//if (tokenarray[j + 1].token == T_OP_BRACKET || tokenarray[j + 1].tokval == '(')
+							//	hasExprBracket = TRUE;
+							//else
+							//	hasExprBracket = FALSE;
 							break;
 						}
 						else if ((tokenarray[j].token == T_DIRECTIVE && tokenarray[j].dirtype == DRT_INVOKE) ||
@@ -220,7 +219,7 @@ static void ExpandObjCalls(char *line, struct asm_tok tokenarray[])
 						else if (tokenarray[j].token == T_ID && tsym && tsym->sym.isproc)
 						{
 							inParam = TRUE;
-							inProc = TRUE;
+							//inProc = TRUE;
 							break;
 						}
 					}
@@ -595,7 +594,8 @@ static void ExpandStaticObjCalls(char *line, struct asm_tok tokenarray[])
 {
 	int i, j;
 	struct asym *sym = NULL;
-	int opIdx, clIdx;
+	int opIdx;
+	int clIdx = 0;
 	int method;
 	int type;
 	char newline[MAX_LINE_LEN];
@@ -605,7 +605,7 @@ static void ExpandStaticObjCalls(char *line, struct asm_tok tokenarray[])
 	bool inParam = FALSE;
 	bool inExpr = FALSE;
 	bool inProc = FALSE;
-	bool hasExprBracket = FALSE;
+	//bool hasExprBracket = FALSE;
 	struct dsym *tsym = NULL;
 
 	memset(&newline, 0, MAX_LINE_LEN);
@@ -630,10 +630,10 @@ static void ExpandStaticObjCalls(char *line, struct asm_tok tokenarray[])
 							if (tokenarray[j].token == T_DIRECTIVE && (tokenarray[j].dirtype == DRT_HLLSTART || tokenarray[j].dirtype == DRT_HLLEND))
 							{
 								inExpr = TRUE;
-								if (tokenarray[j + 1].token == T_OP_BRACKET || tokenarray[j + 1].tokval == '(')
-									hasExprBracket = TRUE;
-								else
-									hasExprBracket = FALSE;
+								//if (tokenarray[j + 1].token == T_OP_BRACKET || tokenarray[j + 1].tokval == '(')
+								//	hasExprBracket = TRUE;
+								//else
+								//	hasExprBracket = FALSE;
 								break;
 							}
 							else if ((tokenarray[j].token == T_DIRECTIVE && tokenarray[j].dirtype == DRT_INVOKE) ||
@@ -776,8 +776,6 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 	struct dsym *sym;
 	char newline[MAX_LINE_LEN];
 	int clIdx, opIdx;
-	int tokenCount;
-	struct asm_tok *tokenarray2;
 	char *p = newline;
 	char idxStack[] = { 0, 0, 0, 0 };
 	int stackPt = -1;
diff --git a/proc.c b/proc.c
index 3824397c..67680f90 100644
--- a/proc.c
+++ b/proc.c
@@ -130,12 +130,14 @@ static const enum special_token sysV64_regsZMM[] = { T_ZMM0, T_ZMM1, T_ZMM2, T_Z
 static const uint_16 win64_nvgpr = 0xF0E8;
 
 /* win64 non-volatile XMM regs: XMM6-XMM15 */
-static const uint_16 win64_nvxmm = 0xFFC0;
+//static const uint_16 win64_nvxmm = 0xFFC0;
 
+/*
 static const int sysv_maxreg[] = {
 	sizeof(sysV64_regs) / sizeof(sysV64_regs[0]),
 	sizeof(sysV64_regs) / sizeof(sysV64_regs[0]),
 };
+*/
 
 #endif
 
@@ -2720,11 +2722,11 @@ static void win64_SaveRegParams_RSP(struct proc_info *info)
 	int i;
 	struct dsym *param;
 	if (ModuleInfo.win64_flags & W64F_SMART) {
-		uint_16        *regist;
+		//uint_16        *regist;
 		info->home_taken = 0;
 		memset(info->home_used, 0, 6);
-		if (info->regslist)
-			regist = info->regslist;
+		//if (info->regslist)
+		//	regist = info->regslist;
 		if (CurrProc->sym.langtype == LANG_VECTORCALL) {
 			for (i = 0, param = info->paralist; param && (i < 6); i++) {
 				/* v2.05: save XMMx if type is float/double */
@@ -3001,10 +3003,10 @@ static void write_win64_default_prologue_RBP(struct proc_info *info)
 	const char * const  *ppfmt;
 	int                 i;
 	int                 cnt;
-	int                 cntxmm;
+	int                 cntxmm = 0;
 	int                 resstack = ((ModuleInfo.win64_flags & W64F_AUTOSTACKSP) ? sym_ReservedStack->value : 0);
 	int                 stackadj = 0;
-	int                 subAmt = 0;
+	//int                 subAmt = 0;
 	int                 saved = 0;
 
 	check_proc_fpo(info);
@@ -3035,7 +3037,6 @@ static void write_win64_default_prologue_RBP(struct proc_info *info)
 		}
 	
 		/* Save the non-volatile registers */
-		cntxmm = 0;
 		if (info->regslist) {
 			regist = info->regslist;
 			for (cnt = *regist++; cnt; cnt--, regist++) {
@@ -3117,7 +3118,7 @@ static void write_win64_default_prologue_RBP(struct proc_info *info)
 			#endif
 			if (info->localsize + stackadj + resstack > 0)
 			{
-				subAmt = info->localsize + stackadj + sym_ReservedStack->value;
+				//subAmt = info->localsize + stackadj + sym_ReservedStack->value;
 				
 				if (Options.frameflags)
 				{
@@ -3137,7 +3138,7 @@ static void write_win64_default_prologue_RBP(struct proc_info *info)
 		}
 		else if (stackadj + info->localsize > 0 && ModuleInfo.frame_auto)
 		{
-			subAmt = info->localsize + stackadj;
+			//subAmt = info->localsize + stackadj;
 
 			if (Options.frameflags)
 			{
@@ -3255,7 +3256,7 @@ static void write_win64_default_prologue_RSP(struct proc_info *info)
 	int                 cnt;
 	int                 stackSize;
 	int                 resstack = ((ModuleInfo.win64_flags & W64F_AUTOSTACKSP) ? sym_ReservedStack->value : 0);
-	int pushed = 0;
+	//int pushed = 0;
 
 	if (Parse_Pass == PASS_1)
 	{
@@ -3276,8 +3277,8 @@ static void write_win64_default_prologue_RSP(struct proc_info *info)
 #if STACKBASESUPP
 
 	info->pushed_reg = 0; /*count of pushed registers */
-	if (info->regslist != 0)
-		pushed = *(info->regslist);
+	//if (info->regslist != 0)
+	//	pushed = *(info->regslist);
 
 #endif
 
@@ -3960,9 +3961,7 @@ static void SetLocalOffsets_RBP(struct proc_info *info)
 	struct dsym *curr     = NULL;
 	int         cntxmm    = 0;
 	int         cntstd    = 0;
-	int         start     = 0;
-	int         rspalign  = TRUE;
-	int         align     = CurrWordSize;
+	//int         align     = CurrWordSize;
 	int         cnt       = 0;
 	uint_16     *regs     = NULL;
 	int         stackAdj  = 0;
@@ -3971,8 +3970,8 @@ static void SetLocalOffsets_RBP(struct proc_info *info)
 	int         resstack  = ((ModuleInfo.win64_flags & W64F_AUTOSTACKSP) ? sym_ReservedStack->value : 0);
 
 	/* Check if the procedure requires 16byte alignment of all locals */
-	if (ModuleInfo.win64_flags & W64F_STACKALIGN16)
-		align = 16;
+	//if (ModuleInfo.win64_flags & W64F_STACKALIGN16)
+	//	align = 16;
 
 	/* Check if the procedure can have FPO */
 	check_proc_fpo(info);
@@ -4126,13 +4125,13 @@ static void SetLocalOffsets_RSP(struct proc_info *info)
 	int                 start = 0;
 	uint_16             *regist;
 	int                 cnt;
-	unsigned char       xmmflag = 1;
+	//unsigned char       xmmflag = 1;
 	unsigned char       ymmflag = 0;
-	unsigned			localadj;
-	unsigned			paramadj;
+	//unsigned			localadj;
+	//unsigned			paramadj;
 	int                 rspalign = FALSE;
 	int                 align = CurrWordSize;
-	unsigned char       zmmflag = 0;
+	//unsigned char       zmmflag = 0;
 	regist = info->regslist;
 	rspalign = TRUE;
 	/* in 64-bit, if the FRAME attribute is set, the space for the registers
@@ -4142,12 +4141,16 @@ static void SetLocalOffsets_RSP(struct proc_info *info)
 	*/
 	if (info->regslist) {
 		for (cnt = *regist++; cnt; cnt--, regist++) {
+			/*
 			if (GetValueSp(*regist) & OP_XMM)
 				xmmflag = 1;
 			else if (GetValueSp(*regist) & OP_YMM)
 				ymmflag = 1;
 			else if (GetValueSp(*regist) & OP_ZMM)
 				zmmflag = 1;
+			*/
+			if (GetValueSp(*regist) & OP_YMM)
+				ymmflag = 1;
 		}
 	}
 	if (ymmflag) XYZMMsize = 32;
@@ -4175,6 +4178,7 @@ static void SetLocalOffsets_RSP(struct proc_info *info)
 			info->localsize += XYZMMsize * cntxmm;
 		}
 		DebugMsg1(("SetLocalOffsets_RSP(%s): cntxmm=%u cntstd=%u start=%u align=%u localsize=%u\n", CurrProc->sym.name, cntxmm, cntstd, start, align, info->localsize));
+		(void)start;
 	}
 	/* scan the locals list and set member sym.offset */
 	for (curr = info->locallist; curr; curr = curr->nextlocal)
@@ -4213,6 +4217,7 @@ static void SetLocalOffsets_RSP(struct proc_info *info)
 	* but the final value of this space is known at the procedure's END only.
 	* Hence in this case the values calculated below are "preliminary".
 	*/
+/*
 	if (info->fpo) {
 
 		if (rspalign) {
@@ -4225,6 +4230,7 @@ static void SetLocalOffsets_RSP(struct proc_info *info)
 			paramadj = info->localsize + cntstd * CurrWordSize - CurrWordSize;
 		}
 	}
+*/
 }
 
 #endif
@@ -4881,13 +4887,13 @@ static ret_code write_default_prologue(void)
 {
 	struct proc_info    *info;
 	uint_8              oldlinenumbers;
-	int                 resstack = 0;
+	//int                 resstack = 0;
 	bool                OldState = FALSE;
 
 	info = CurrProc->e.procinfo;
 
-	if (ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP))
-		resstack = sym_ReservedStack->value;
+	//if (ModuleInfo.Ofssize == USE64 && ModuleInfo.fctype == FCT_WIN64 && (ModuleInfo.win64_flags & W64F_AUTOSTACKSP))
+	//	resstack = sym_ReservedStack->value;
 
 	if (ModuleInfo.Ofssize == USE64)
 	{
@@ -5045,9 +5051,6 @@ static void SetLocalOffsets(struct proc_info *info)
 void write_prologue(struct asm_tok tokenarray[])
 /************************************************/
 {
-	struct dsym *curr;
-	int		align = CurrWordSize;
-
 	/* reset @ProcStatus flag */
 	ProcStatus &= ~PRST_PROLOGUE_NOT_DONE;
 	CurrProc->e.procinfo->prologueDone = FALSE;
diff --git a/pseudoFilter.c b/pseudoFilter.c
index 67c4a1d5..835c6e64 100644
--- a/pseudoFilter.c
+++ b/pseudoFilter.c
@@ -13,7 +13,7 @@
 
 /**
 	 * C++ version 0.4 char* style "itoa":
-	 * Written by Lukás Chmela
+	 * Written by Lukï¿½s Chmela
 	 * Released under GPLv3.
 
 	 */
@@ -46,7 +46,7 @@ char* itoa(int value, char* result, int base) {
 int get_pseudoCMPXX(char* dst, char* p1, int index)
 /******************************************************************/
 {
-  int i;
+  int i = 0;
 
   switch (index) {
   case T_CMPEQPD:
@@ -113,8 +113,8 @@ int get_pseudoCMPXX(char* dst, char* p1, int index)
 int get_pseudoVCMPXX(char* dst, char* p1, int index)
 /******************************************************************/
 {
-  int i;
-  bool hadComment = FALSE;
+  int i = 0;
+  //bool hadComment = FALSE;
   switch (index) {
   case T_VCMPEQPD:
   case T_VCMPLTPD:
@@ -266,7 +266,7 @@ int get_pseudoVCMPXX(char* dst, char* p1, int index)
     * p1 = ' ';
   while (*p1) {
       if (*p1 == ';') {
-          hadComment = TRUE;
+          //hadComment = TRUE;
           break;
       }
       p1++;
diff --git a/simd.c b/simd.c
index 728de0c1..3401181c 100644
--- a/simd.c
+++ b/simd.c
@@ -17,8 +17,6 @@ extern void     AddLineQueueX(const char *fmt, ...);
 
 void AddSimdTypes()
 {
-	struct asym* sym = 0;
-
 	AddLineQueue("__m128b struct");
 	AddLineQueue("b0 BYTE ?");
 	AddLineQueue("b1 BYTE ?");
diff --git a/simsegm.c b/simsegm.c
index 85e63008..a7d5bd18 100644
--- a/simsegm.c
+++ b/simsegm.c
@@ -210,7 +210,7 @@ ret_code SimplifiedSegDir( int i, struct asm_tok tokenarray[] )
  */
 {
     const char  *name = NULL;
-    char        init;
+    char        init = FALSE;
     int         type;
     struct expr opndx;
 
diff --git a/tokenize.c b/tokenize.c
index c5128c4d..21a8aeae 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -948,14 +948,10 @@ static ret_code get_id_in_backquotes( struct asm_tok *buf, struct line_status *p
 static ret_code get_id( struct asm_tok *buf, struct line_status *p )
 /******************************************************************/
 {
-    //struct ReservedWord *resw;
     char *src = p->input;
     char *dst = p->output;
-    char *p1  = p->input;
     int  index;
     unsigned size;
-	int len = 0;
-	int i = 0;
 #if CONCATID || DOTNAMEX
 continue_scan:
 #endif

From 4057659ae7ab2f9db1f299b773476753db8a5c77 Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Fri, 6 Dec 2024 18:36:53 +0100
Subject: [PATCH 09/11] fix debug builds

---
 parser.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/parser.c b/parser.c
index a6707686..9ff85173 100644
--- a/parser.c
+++ b/parser.c
@@ -3755,7 +3755,7 @@ ret_code ParseLine(struct asm_tok tokenarray[]) {
 				}
 				if (j <= 2) 
 				{
-					DebugMsg(("ParseLine(%s,%u): avx not enough operands (%u)\n", instr, CurrOpnd, opndx[OPND2].kind, j));
+					DebugMsg(("ParseLine(%s,%u): avx not enough operands (%u)\n", GetResWName(CodeInfo.token, NULL), CurrOpnd, opndx[OPND2].kind, j));
 				}
 				else
 
@@ -3941,14 +3941,14 @@ ret_code ParseLine(struct asm_tok tokenarray[]) {
 		/* the first op must be EAX/AX or RAX/EAX. The operand class
 		* used in the instruction table is OP_A ( which is AL/AX/EAX/RAX ). */
 		if ( ( CodeInfo.opnd[OPND1].type & ( CodeInfo.Ofssize == USE64 ? OP_R64 | OP_R32 : OP_R32 | OP_R16 ) ) == 0 ) {
-			DebugMsg(("ParseLine(%s): opnd1 unexpected type=%X\n", instr, CodeInfo.opnd[OPND1].type ));
+			DebugMsg(("ParseLine(%s): opnd1 unexpected type=%X\n", GetResWName(CodeInfo.token, NULL), CodeInfo.opnd[OPND1].type ));
 			return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
 		}
 		/* the INVLPGA instruction has a fix second operand (=ECX). However, there's no
 		 * operand class for ECX alone. So it has to be ensured here that the register IS ecx. */
 		if ( CodeInfo.token == T_INVLPGA )
 			if ( ( CodeInfo.rm_byte & BIT_345 ) != ( 1 << 3 ) ) { /* ECX is register 1 */
-				DebugMsg(("ParseLine(%s): opnd2 is not ecx\n", instr ));
+				DebugMsg(("ParseLine(%s): opnd2 is not ecx\n", GetResWName(CodeInfo.token, NULL) ));
 				return( EmitErr( INVALID_INSTRUCTION_OPERANDS ) );
 			}
 	#endif

From 33ae21341bd2c5d569b74813afa5cbf617f4eb5c Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Sat, 7 Dec 2024 14:17:55 +0100
Subject: [PATCH 10/11] GCC warning -Wdiscarded-qualifiers

---
 H/errmsg.h         |  2 +-
 H/globals.h        |  7 +++++--
 Makefile-Linux.mak | 12 ++----------
 assemble.c         |  2 +-
 bin.c              |  4 ++--
 coff.c             |  2 +-
 dbgcv.c            |  2 +-
 end.c              |  2 +-
 errmsg.c           |  2 +-
 expans.c           |  4 ++--
 hll.c              | 12 +++++++-----
 invoke.c           |  6 +++---
 loop.c             |  2 +-
 macrolib.c         | 20 ++++++++++++--------
 main.c             |  4 ++--
 parser.c           | 12 ++++++++----
 preproc.c          | 30 +++++++++++++++++++-----------
 proc.c             | 11 +++++++----
 segment.c          |  2 +-
 simsegm.c          | 10 ++++++----
 symbols.c          |  9 ++++++---
 tokenize.c         | 24 ++++++++++++++++--------
 types.c            | 17 ++++++++++-------
 23 files changed, 115 insertions(+), 83 deletions(-)

diff --git a/H/errmsg.h b/H/errmsg.h
index d200f3b5..ded27437 100644
--- a/H/errmsg.h
+++ b/H/errmsg.h
@@ -65,7 +65,7 @@ extern int  EmitError( int msgnum );
 extern int  EmitErr( int msgnum, ... );
 extern void EmitWarn( int level, int msgnum, ... );
 extern void PrintNote( int msgnum, ... );
-extern char *ErrnoStr( void );
+extern const char *ErrnoStr( void );
 extern int  write_logo( void );
 extern void PrintUsage( void );
 //extern void SeekError( void );
diff --git a/H/globals.h b/H/globals.h
index 3a0fe3d2..d843ab4b 100644
--- a/H/globals.h
+++ b/H/globals.h
@@ -738,7 +738,7 @@ struct module_vars {
     struct qdesc        LibQueue;        /* includelibs */
     struct qdesc	    LinkQueue;	     /* .pragma comment(linker,"/..") */
     struct dll_desc     *DllQueue;       /* dlls of OPTION DLLIMPORT */
-    char                *imp_prefix;
+    const char          *imp_prefix;
     FILE                *curr_file[NUM_FILE_TYPES];  /* ASM, ERR, OBJ and LST */
     char                *curr_fname[NUM_FILE_TYPES];
     char *              *FNames;         /* array of input files */
@@ -951,4 +951,7 @@ extern char             *num2hex64(uint_64 value, char *buffer);
 extern char             *ConvertSectionName( const struct asym *, enum seg_type *pst, char *buffer );
 extern void             RewindToWin64(void);
 
-#endif
+/* empty string (char *)"" in types.c */
+extern char STR_EMPTY[1];
+
+#endif /* _GLOBALS_H_INCLUDED */
diff --git a/Makefile-Linux.mak b/Makefile-Linux.mak
index 3790abcb..a3e279fb 100644
--- a/Makefile-Linux.mak
+++ b/Makefile-Linux.mak
@@ -6,12 +6,11 @@ TARGET1=uasm
 ifndef DEBUG
 DEBUG=0
 endif
-ifndef CLANG
-CLANG=0
-endif
 
 inc_dirs  = -IH
 
+CC = gcc
+
 #cflags stuff
 
 ifeq ($(DEBUG),0)
@@ -24,13 +23,6 @@ extra_c_flags = -DDEBUG_OUT -g
 OUTD=GccUnixD
 endif
 
-ifeq ($(CLANG),0)
-CC = gcc
-extra_c_flags += -Wno-discarded-qualifiers
-else
-CC = clang
-endif
-
 c_flags =-D __UNIX__ $(extra_c_flags)
 
 .SUFFIXES:
diff --git a/assemble.c b/assemble.c
index 35f21cc3..e47dc457 100644
--- a/assemble.c
+++ b/assemble.c
@@ -1425,7 +1425,7 @@ void close_files( void )
 #endif
 #endif
 
-static char *GetExt( int type )
+static const char *GetExt( int type )
 /*****************************/
 {
     switch ( type ) {
diff --git a/bin.c b/bin.c
index 94fc673f..8ead4d12 100644
--- a/bin.c
+++ b/bin.c
@@ -993,10 +993,10 @@ static void pe_emit_import_data( void )
     int type = 0;
 #if AMD64_SUPPORT
     int ptrtype = ( ModuleInfo.defOfssize == USE64 ? T_QWORD : T_DWORD );
-    char *align = ( ModuleInfo.defOfssize == USE64 ? "ALIGN(8)" : "ALIGN(4)" );
+    const char *align = ( ModuleInfo.defOfssize == USE64 ? "ALIGN(8)" : "ALIGN(4)" );
 #else
     int ptrtype = T_DWORD;
-    char *align = "DWORD";
+    const char *align = "DWORD";
 #endif
 
     DebugMsg(("pe_emit_import_data enter\n" ));
diff --git a/coff.c b/coff.c
index 134ffa28..ec8636f3 100644
--- a/coff.c
+++ b/coff.c
@@ -340,7 +340,7 @@ static uint_32 CRC32Comdat( uint_8 *lpBuffer, uint_32 dwBufLen, uint_32 dwCRC )
     return( dwCRC );
 }
 
-static void coff_write_symbol(char* name, int_32 strpos, int_32 value,
+static void coff_write_symbol(const char* name, int_32 strpos, int_32 value,
     int section, int type, int storageclass, int aux)
 {
     IMAGE_SYMBOL sym;
diff --git a/dbgcv.c b/dbgcv.c
index 6e0abcae..7c14c057 100644
--- a/dbgcv.c
+++ b/dbgcv.c
@@ -123,7 +123,7 @@ struct leaf32 {
 
 #pragma pack(pop)
 
-uint_8* SetPrefixName(uint_8* p, char* name, int len)
+uint_8* SetPrefixName(uint_8* p, const char* name, int len)
 {
 	if (Options.debug_symbols < CV_SIGNATURE_C13)
 		*p++ = len;
diff --git a/end.c b/end.c
index d6c2a752..2dcf5797 100644
--- a/end.c
+++ b/end.c
@@ -209,7 +209,7 @@ ret_code EndDirective( int i, struct asm_tok tokenarray[] )
         tokenarray[i].token = T_ID;
         tokenarray[i].string_ptr = (char *)szStartAddr;
         tokenarray[i+1].token = T_FINAL;
-        tokenarray[i+1].string_ptr = "";
+        tokenarray[i+1].string_ptr = STR_EMPTY;
         Token_Count = i+1;
     }
     /* v2.11: flag EXPF_NOUNDEF added - will return ERROR if start label isn't defined */
diff --git a/errmsg.c b/errmsg.c
index e28cc0fe..de7b119f 100644
--- a/errmsg.c
+++ b/errmsg.c
@@ -385,7 +385,7 @@ void EmitWarn( int level, int msgnum, ... )
     }
 }
 
-char *ErrnoStr( void )
+const char *ErrnoStr( void )
 /********************/
 {
     static char buffer[32];
diff --git a/expans.c b/expans.c
index 2a2e44c3..1bdd27bf 100644
--- a/expans.c
+++ b/expans.c
@@ -254,7 +254,7 @@ int RunMacro( struct dsym *macro, int idx, struct asm_tok tokenarray[], char *ou
             memcpy( currparm, tokenarray[0].string_ptr, i+1 );
             currparm = GetAlignedPointer( currparm, i );
         } else
-            mi.parm_array[parmidx] = "";
+            mi.parm_array[parmidx] = STR_EMPTY;
         parmidx++;
     }
 #endif
@@ -580,7 +580,7 @@ int RunMacro( struct dsym *macro, int idx, struct asm_tok tokenarray[], char *ou
                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=>%s<\n", macro->sym.name, parmidx, currparm ));
                 currparm = GetAlignedPointer( currparm, ptr - currparm );
             } else {
-                mi.parm_array[parmidx] = "";
+                mi.parm_array[parmidx] = STR_EMPTY;
                 DebugMsg1(("RunMacro(%s.%u): curr parameter value=><\n", macro->sym.name, parmidx ));
             }
         } /*end if */
diff --git a/hll.c b/hll.c
index f7cbff77..8cc68fbf 100644
--- a/hll.c
+++ b/hll.c
@@ -89,6 +89,8 @@ void myatoi128(const char* src, uint_64 dst[], int base, int size);
 #define EOLSTR  "\n"
 #endif
 
+static char STR_DOTFOR[] = { '.','f','o','r', 0 };
+
 /* values for struct hll_item.cmd */
 enum hll_cmd {
     HLL_IF,
@@ -1151,7 +1153,7 @@ static ret_code CheckCXZLines(char* p)
     int lines = 0;
     int i;
     int addchars;
-    char* px;
+    const char* px;
     bool NL = TRUE;
 
     DebugMsg1(("CheckCXZLines enter, p=>%s<\n", p));
@@ -1703,7 +1705,7 @@ ret_code HllStartDir(int i, struct asm_tok tokenarray[])
         //copy the counter to the buffer
         cmcnt = 0;
         forbuffcnt[0] = NULLC;
-        hll->condlines = "";
+        hll->condlines = STR_EMPTY;
         for (b = 0; forbuff[j] != ')'; b++, j++) {
             forbuffcnt[b] = forbuff[j];
             if (forbuffcnt[b] == ',' && forbuff[j - 1] != 39 && forbuff[j + 1] != 39) ++cmcnt;
@@ -1729,7 +1731,7 @@ ret_code HllStartDir(int i, struct asm_tok tokenarray[])
             memcpy(hll->counterlines, forbuffcnt, size);
             hll->cmcnt = cmcnt + 1;
         }
-        else hll->counterlines = "";    //there is nothing after the second ':'
+        else hll->counterlines = STR_EMPTY;    //there is nothing after the second ':'
         if (forbuffcond[0]) {
             //jump to test the first time
             hll->labels[LTEST] = GetHllLabel();
@@ -1737,7 +1739,7 @@ ret_code HllStartDir(int i, struct asm_tok tokenarray[])
             strcpy(transformed, ".for ");
             strcat(transformed, forbuffcond);
             strcat(transformed, "\0");
-            tokenarray[0].string_ptr = ".for\0";
+            tokenarray[0].string_ptr = STR_DOTFOR; /* ".for\0"; */
             tokenarray[0].tokpos = transformed;
             Token_Count = Tokenize(tokenarray[0].tokpos, 0, tokenarray, 0);
             if (tokenarray[i].token != T_FINAL) {
@@ -1750,7 +1752,7 @@ ret_code HllStartDir(int i, struct asm_tok tokenarray[])
                 }
             }
             else
-                hll->condlines = "";
+                hll->condlines = STR_EMPTY;
         }
         if (forbuffcnt[0] == NULLC && forbuffcond[0] == NULLC)
             hll->labels[LCONT] = hll->labels[LSTART];
diff --git a/invoke.c b/invoke.c
index c2c4bbf2..1711d498 100644
--- a/invoke.c
+++ b/invoke.c
@@ -3247,7 +3247,7 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 	char *pSrc;
 	uint_16 *pDest;
 	uint_8 *pDest2;
-	char *labelstr = "__ls";
+	const char *labelstr = "__ls";
 	char buf[32];
 	char c1;
 	char c2;
@@ -4216,8 +4216,8 @@ static int PushInvokeParam(int i, struct asm_tok tokenarray[], struct dsym *proc
 					AddLineQueueX(" push %r", T_AX);
 				}
 				else { /* cpu >= 80186 */
-					char *instr = "";
-					char *suffix;
+					const char *instr = "";
+					const char *suffix;
 					int qual = EMPTY;
 					//if ( asize != psize ) {
 					if (psize != pushsize) {
diff --git a/loop.c b/loop.c
index c992f7c7..a86275e7 100644
--- a/loop.c
+++ b/loop.c
@@ -164,7 +164,7 @@ ret_code LoopDirective( int i, struct asm_tok tokenarray[] )
     /* now make a temporary macro */
     macro = &tmpmacro;
     memset( &tmpmacro, 0, sizeof(tmpmacro) );
-    tmpmacro.sym.name = "";
+    tmpmacro.sym.name = STR_EMPTY;
     tmpmacro.e.macroinfo = &macinfo;
     memset( &macinfo, 0, sizeof(macinfo) );
     macinfo.srcfile = get_curr_srcfile();
diff --git a/macrolib.c b/macrolib.c
index 404e6f4a..0d64751e 100644
--- a/macrolib.c
+++ b/macrolib.c
@@ -34,15 +34,15 @@
 #define MACRO_COUNT32 36
 
 /* MACRO names  */
-char *macName64[] = {
+const char *macName64[] = {
   "NOTMASK128", "GETMASK128", "REGS15STORAGE", "MOV64", "MOV128", "MOVXMMR128","SLXMMR","SHIFTLEFT128","SRXMMR","SHIFTRIGHT128","MEMALLOC", "MEMFREE", "CSTR", "WSTR", "FP4", "FP8", "FP10", "LOADSS", "LOADSD", "LOADPS", "ALIGNADDR", "RV", "REPARG", "EXPAND_PREFIX", "_ARRAY", "_DELETEARRAY", "OINTERFACE", "ENDOINTERFACE", "CVIRTUAL", "CLASS", "ENDCLASS", "CMETHOD", "METHOD", "STATICMETHOD", "VECMETHOD", "STATICVECMETHOD", "ENDMETHOD", "_DECLARE", "_STATICREF", "_NEW", "_RBXNEW", "_ITEM", "_ITEMR", "_INVOKE", "_I", "_STATIC", "_DELETE", "_VINVOKE", "_V", "CSTATIC", "LOADMSS", "LOADMSD", "UINVOKE", "ASFLOAT", "ASDOUBLE", "R4P", "R8P", "arginvoke", "COMINTERFACE", "ENDCOMINTERFACE", "ENDMETHODS", "_DEREF", "_DEREFI", "_SINVOKE", "RAWINTERFACE", "ENDRAWINTERFACE", "_DEREFR", "_DEREFRR","STDFUNC"
 };
-char *macName32[] = {
+const char *macName32[] = {
  "NOTMASK128", "GETMASK128", "MOV64", "MOV128", "MOVXMMR128","SLXMMR","SHIFTLEFT128","SRXMMR","SHIFTRIGHT128","MEMALLOC","MEMFREE","CSTR","WSTR","FP4","FP8","FP10","LOADSS","LOADPS","ALIGNADDR", "RV", "REPARG", "EXPAND_PREFIX", "LOADMSS", "LOADMSD", "UINVOKE", "ASFLOAT", "ASDOUBLE", "R4P", "R8P", "arginvoke", "COMINTERFACE", "ENDCOMINTERFACE", "_VINVOKE", "_V", "CVIRTUAL", "ENDMETHODS"
 };
 
 /* MACRO definitions */
-char *macDef64[] = {
+const char *macDef64[] = {
 	"NOTMASK128 MACRO reg:REQ, field:REQ",
 	"GETMASK128 MACRO reg:REQ, field:REQ",
 	"REGS15STORAGE MACRO",
@@ -113,7 +113,7 @@ char *macDef64[] = {
 	"_DEREFRR MACRO dref:REQ, itype:REQ, proc:REQ, argCount:REQ, argsAndRefs:VARARG",
 	"STDFUNC MACRO method:REQ, retType:REQ, protoDef:VARARG",
 };
-char *macDef32[] = {
+const char *macDef32[] = {
 	"NOTMASK128 MACRO reg:REQ, field:REQ",
 	"GETMASK128 MACRO reg:REQ, field:REQ",
 	"MOV64 MACRO dst:REQ, imm:REQ",
@@ -223,10 +223,11 @@ void InitAutoMacros64(void)
 	uint_32 j = 0;
 	uint_32 start_pos = 0;
 	char  *srcLines[512]; // NB: 512 is the max number of lines of macro code per macro.  
+	char buffer[512];
 
 	//                    1   2   3   4  5  6  7   8   9   10  11 12 13  14 15 16 17 18 19 20  21 22 23  24  25  26 27 28  29  30  31  32 33  34  35  36  37  38 39 40  41  42 43 44  45  46  47  48  49  50 51  52  53  54 55 56 57 58   59  60 61 62   63   64  65  66 67 68 69
 	uint_32 macroLen[] = {17, 11, 29, 3, 3, 8, 37, 33, 37, 33, 7, 6, 10, 6, 7, 7, 7, 8, 8, 10, 3, 7, 11, 19, 10, 2, 10, 2, 18,  9, 14, 6, 39, 39, 39, 39, 12, 5, 2, 20, 21, 2, 2, 11, 38, 38, 11, 45, 91, 6, 10, 10, 37, 1, 1, 1, 1, 256, 10, 6, 6, 106, 137, 11, 7 , 2, 9, 4, 18 }; // Count of individual lines of macro-body code.
-	char *macCode[] = {
+	const char *macCode[] = {
 /*1 NOTMASK128*/		"IFNDEF GMASK",".data","GMASK OWORD 0","ENDIF","IFNDEF NOTMASK",".data","NOTMASK OWORD -1","ENDIF",".code","IF @Arch EQ 1","movups reg, MASK field","pxor reg, NOTMASK","ELSE","vmovups reg, MASK field","vpxor reg, reg, NOTMASK","ENDIF","ENDM",NULL,
 /*2 GETMASK128*/		"IFNDEF GMASK",".data","GMASK OWORD 0","ENDIF",".code","IF @Arch EQ 1","movups reg, MASK field","ELSE","vmovups reg, MASK field","ENDIF","ENDM",NULL,
 /*3 REGS15STORAGE*/		"IFNDEF RRAX",".data?", " RRAX dq ?", " RRCX dq ?", " RRDX dq ?", " RRBX dq ?", " RRDI dq ?", " RRSI dq ?", " RRBP dq ?", " RRSP dq ?", " RR8  dq ?", " RR9  dq ?", " RR10 dq ?", " RR11 dq ?", " RR12 dq ?", " RR13 dq ?", " RR14 dq ?", " RR15 dq ?", " RXMM0 OWORD ?", " RXMM1 OWORD ?", " RXMM2 OWORD ?", " RXMM3 OWORD ?", " RXMM4 OWORD ?", " RXMM5 OWORD ?", " RXMM6 OWORD ?", " RXMM7 OWORD ?", "ENDIF", " .code", "ENDM", NULL,
@@ -308,7 +309,8 @@ void InitAutoMacros64(void)
 				strcpy(srcLines[j], macCode[(start_pos + j)]);
 		}
 		mac = CreateMacro(macName64[i]);
-		ModuleInfo.token_count = Tokenize(macDef64[i], 0, ModuleInfo.tokenarray, 0);
+		strcpy(buffer, macDef64[i]);
+		ModuleInfo.token_count = Tokenize(buffer, 0, ModuleInfo.tokenarray, 0);
 		StoreAutoMacro(mac, 2, ModuleInfo.tokenarray, TRUE, srcLines, 0, macroLen[i]);
 		start_pos += macroLen[i] + 1;
 	}
@@ -321,9 +323,10 @@ void InitAutoMacros32(void)
 	uint_32 j = 0;
 	uint_32 start_pos = 0;
 	char  *srcLines[128]; // NB: 128 is the max number of lines of macro code per macro.
+	char buffer[512];
 
 	uint_32 macroLen[] = {17, 11, 3, 3, 8, 54, 46, 54, 46, 7, 6, 6, 6, 7, 7, 7, 8, 10, 3, 7, 11, 19, 10, 10, 37, 1, 1, 1, 1, 37, 6, 2, 23, 54, 10, 6 }; // Count of individual lines of macro-body code.
-	char *macCode[] = {
+	const char *macCode[] = {
 		"IFNDEF GMASK",".data","GMASK OWORD 0","ENDIF","IFNDEF NOTMASK",".data","NOTMASK OWORD -1","ENDIF",".code","IF @Arch EQ 1","movups reg, MASK field","pxor reg, NOTMASK","ELSE","vmovups reg, MASK field","vpxor reg, reg, NOTMASK","ENDIF","ENDM",NULL,
 		"IFNDEF GMASK",".data","GMASK OWORD 0","ENDIF",".code","IF @Arch EQ 1","movups reg, MASK field","ELSE","vmovups reg, MASK field","ENDIF","ENDM",NULL,
 		"mov dword ptr dst, LOW32(imm)", "mov dword ptr dst + 4, HIGH32(imm)", "ENDM", NULL,
@@ -371,7 +374,8 @@ void InitAutoMacros32(void)
 			strcpy(srcLines[j], macCode[(start_pos + j)]);
 		}
 		mac = CreateMacro(macName32[i]);
-		ModuleInfo.token_count = Tokenize(macDef32[i], 0, ModuleInfo.tokenarray, 0);
+		strcpy(buffer, macDef32[i]);
+		ModuleInfo.token_count = Tokenize(buffer, 0, ModuleInfo.tokenarray, 0);
 		StoreAutoMacro(mac, 2, ModuleInfo.tokenarray, TRUE, srcLines, 0, macroLen[i]);
 		start_pos += macroLen[i] + 1;
 	}
diff --git a/main.c b/main.c
index a42a9736..cb15547a 100644
--- a/main.c
+++ b/main.c
@@ -91,9 +91,9 @@ int main(int argc, char **argv)
 
 	pEnv = getenv("UASM");
 	if (pEnv == NULL)
-		pEnv = "";
+		pEnv = STR_EMPTY;
 	argv[0] = pEnv;
-	
+
 	/* Set the default module architecture to SSE */
 	//MODULEARCH = ARCH_SSE;
 
diff --git a/parser.c b/parser.c
index 9ff85173..cb5f4294 100644
--- a/parser.c
+++ b/parser.c
@@ -89,6 +89,10 @@ struct asm_tok      xmmOver0;				/* xmmword override tokens for -Zg switch (masm
 struct asm_tok      xmmOver1;
 struct asm_tok      dsOver;
 
+static char STR_XMMWORD[] = { 'x','m','m','w','o','r','d', 0 };
+static char STR_PTR[] = { 'p','t','r', 0 };
+static char STR_DS[] = { 'd','s', 0 };
+
 /* linked lists of:     index
  *--------------------------------
  * - undefined symbols  TAB_UNDEF
@@ -2970,7 +2974,7 @@ static ret_code check_size( struct code_info *CodeInfo, const struct expr opndx[
              */
             if( op1_size == 0 ) {
                 if( ( op1 & OP_M_ANY ) && ( op2 & OP_I ) ) {
-                    char *p = "WORD";
+                    const char *p = "WORD";
                     if( (uint_32)CodeInfo->opnd[OPND2].data32l > USHRT_MAX || op2_size == 4 ) {
                         CodeInfo->iswide = 1;
                         DebugMsg1(("check_size: op1=%X op1_size=0, op2=%X, op2_size=%u CodeInfo->data[2]=%X\n", op1, op2, op2_size, CodeInfo->opnd[OPND2].data32l ));
@@ -4108,7 +4112,7 @@ void ProcessFile( struct asm_tok tokenarray[] )
 	xmmOver0.bytval = 15;
 	xmmOver0.dirtype = 15;
 	xmmOver0.tokval = T_XMMWORD;
-	xmmOver0.string_ptr = "xmmword";
+	xmmOver0.string_ptr = STR_XMMWORD;
 	xmmOver0.stringlen = T_XMMWORD;
 	xmmOver0.idarg = T_XMMWORD;
 	xmmOver0.itemlen = T_XMMWORD;
@@ -4123,7 +4127,7 @@ void ProcessFile( struct asm_tok tokenarray[] )
 	xmmOver1.bytval = 4;
 	xmmOver1.dirtype = 4;
 	xmmOver1.tokval = T_PTR;
-	xmmOver1.string_ptr = "ptr";
+	xmmOver1.string_ptr = STR_PTR;
 	xmmOver1.stringlen = T_PTR;
 	xmmOver1.idarg = T_PTR;
 	xmmOver1.itemlen = T_PTR;
@@ -4137,7 +4141,7 @@ void ProcessFile( struct asm_tok tokenarray[] )
 	dsOver.floattype = 3;
 	dsOver.numbase = 3;
 	dsOver.specval = 3;
-	dsOver.string_ptr = "ds";
+	dsOver.string_ptr = STR_DS;
 	dsOver.tokval = 0x0000001c;
 	dsOver.stringlen = 0x0000001c;
 	dsOver.idarg = 0x0000001c;
diff --git a/preproc.c b/preproc.c
index 9ae57637..80197d1f 100644
--- a/preproc.c
+++ b/preproc.c
@@ -35,6 +35,14 @@ int_32 cntppl1;    /* count preprocessed lines 2 */
 int_32 cntppl2;    /* count lines NOT handled by preprocessor */
 #endif
 
+static char STR_INVOKE[] = { 'i','n','v','o','k','e', 0 };
+static char STR_UINVOKE[] = { 'u','i','n','v','o','k','e', 0 };
+static char STR_ARGINVOKE[] = { 'a','r','g','i','n','v','o','k','e','(','%','%',',','%','%',',', 0 };
+static char STR_ADDR[] = { 'A','D','D','R',' ', 0 };
+static char STR_COMMA[] = { ',', 0 };
+static char STR_SPACE[] = { ',', 0 };
+static char STR_PAREN_OPEN[] = { '(', 0 };
+
 /* preprocessor directive or macro procedure is preceded
  * by a code label.
  */
@@ -870,7 +878,7 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 					{
 						// token identifier begins with address of operator.
 						//strcpy(tokenarray[j].string_ptr, "ADDR ");
-						tokenarray[j].string_ptr = "ADDR ";
+						tokenarray[j].string_ptr = STR_ADDR;
 					}
 				}
 
@@ -883,19 +891,19 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 					if (clIdx > opIdx + 1)
 					{
 						tokenarray[clIdx + 1].token = T_FINAL;
-						tokenarray[opIdx + 1].string_ptr = ",";
+						tokenarray[opIdx + 1].string_ptr = STR_COMMA;
 						tokenarray[opIdx + 1].token = T_COMMA;
 					}
 					/* Proc with no params */
 					else
 					{
-						tokenarray[opIdx + 1].string_ptr = "";
+						tokenarray[opIdx + 1].string_ptr = STR_EMPTY;
 						tokenarray[opIdx + 1].token = T_FINAL;
 					}
 					tokenarray[i].token = T_DIRECTIVE;
 					tokenarray[i].tokval = T_INVOKE;
 					tokenarray[i].dirtype = DRT_INVOKE;
-					tokenarray[i].string_ptr = "invoke";
+					tokenarray[i].string_ptr = STR_INVOKE;
 				}
 				else
 				{
@@ -908,24 +916,24 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 						tokenarray[j] = tokenarray[j - 1];
 
 					Token_Count+=2;
-					tokenarray[Token_Count].string_ptr = "";
+					tokenarray[Token_Count].string_ptr = STR_EMPTY;
 					tokenarray[Token_Count].token = T_FINAL;
 					if (clIdx > opIdx + 1)
 					{
-						tokenarray[opIdx + 2].string_ptr = ",";
+						tokenarray[opIdx + 2].string_ptr = STR_COMMA;
 						tokenarray[opIdx + 2].token = T_COMMA;
 					}
 					else
 					{
-						tokenarray[opIdx + 2].string_ptr = " ";
+						tokenarray[opIdx + 2].string_ptr = STR_SPACE;
 					}
 					tokenarray[i].token = T_ID;
 					tokenarray[i].tokval = 0;
 					tokenarray[i].dirtype = 0;
 					if (inExpr && !inParam)
 					{
-						tokenarray[i].string_ptr = "uinvoke";
-						tokenarray[i + 1].string_ptr = "(";
+						tokenarray[i].string_ptr = STR_UINVOKE;
+						tokenarray[i + 1].string_ptr = STR_PAREN_OPEN;
 						tokenarray[i + 1].token = '(';
 						uCnt++; // Increment count of uinvokes, as we only allow 1 per expression.
 						if (uCnt > 1)
@@ -935,8 +943,8 @@ static void ExpandHllCalls(char *line, struct asm_tok tokenarray[], bool inParam
 					}
 					else if (inParam)
 					{
-						tokenarray[i].string_ptr = "arginvoke(%%,%%,";
-						tokenarray[i + 1].string_ptr = ""; 
+						tokenarray[i].string_ptr = STR_ARGINVOKE;
+						tokenarray[i + 1].string_ptr = STR_EMPTY;
 						tokenarray[i + 1].token = 0; 
 					}
 				}
diff --git a/proc.c b/proc.c
index 67680f90..15cf9260 100644
--- a/proc.c
+++ b/proc.c
@@ -821,7 +821,7 @@ static ret_code ParseParams(struct dsym *proc, int i, struct asm_tok tokenarray[
 			if (paracurr)
 				name = paracurr->sym.name;
 			else
-				name = "";
+				name = STR_EMPTY;
 		}
 		else {
 
@@ -2239,7 +2239,7 @@ static void WriteSEHData(struct dsym *proc)
 /*******************************************/
 {
 	struct dsym *xdata;
-	char *segname = ".xdata";
+	char *segname;
 	int i;
 	int simplespec;
 	uint_8 olddotname;
@@ -2251,6 +2251,9 @@ static void WriteSEHData(struct dsym *proc)
 	if (Options.output_format == OFORMAT_ELF || Options.output_format == OFORMAT_BIN || Options.output_format == OFORMAT_MAC)
 		return;
 
+	segname = segnamebuff;
+	strcpy(segname, ".xdata");
+
 	if (endprolog_found == FALSE) {
 		EmitErr(MISSING_ENDPROLOG, proc->sym.name);
 	}
@@ -2276,7 +2279,7 @@ static void WriteSEHData(struct dsym *proc)
 		UNW_VERSION, unw_info.Flags, unw_info.SizeOfProlog,
 		unw_info.CountOfCodes, unw_info.FrameRegister, unw_info.FrameOffset);
 	if (unw_info.CountOfCodes) {
-		char *pfx = "dw";
+		const char *pfx = "dw";
 		buffer[0] = NULLC;
 		/* write the codes from right to left */
 		for (i = unw_info.CountOfCodes; i; i--) {
@@ -2303,7 +2306,7 @@ static void WriteSEHData(struct dsym *proc)
 
 	/* v2.07: ensure that .pdata items are sorted */
 	if (0 == strcmp(SimGetSegName(SIM_CODE), proc->sym.segment->name)) {
-		segname = ".pdata";
+		strcpy(segname, ".pdata");
 		simplespec = (unw_segs_defined & 1);
 		unw_segs_defined = 3;
 	}
diff --git a/segment.c b/segment.c
index 95a9bb8a..78631828 100644
--- a/segment.c
+++ b/segment.c
@@ -175,7 +175,7 @@ void UpdateCurrSegVars( void )
         info->symbol = NULL;
         info->is_flat = FALSE;
         info->error = TRUE;
-        symCurSeg->string_ptr = "";
+        symCurSeg->string_ptr = STR_EMPTY;
     } else {
         info->is_flat = FALSE;
         info->error = FALSE;
diff --git a/simsegm.c b/simsegm.c
index a7d5bd18..4ba5c13d 100644
--- a/simsegm.c
+++ b/simsegm.c
@@ -41,13 +41,15 @@ static const char * const SegmCombine[ SIM_LAST ] = {
     "PUBLIC", "STACK", "PUBLIC", "PUBLIC", "PRIVATE", "PRIVATE", "PUBLIC"
 };
 
+static char STR_FLAT[] = { '_','f','l','a','t', 0 };
+
 char *SimGetSegName( enum sim_seg segno )
 /***************************************/
 {
 	char* segn;
 	segn = SegmNames[segno];
 	if (segn == NULL && ModuleInfo.flat == TRUE)
-		segn = "_flat";
+		segn = STR_FLAT;
     return( segn );
 }
 
@@ -96,9 +98,9 @@ static void close_currseg( void )
 static void SetSimSeg( enum sim_seg segm, const char *name )
 /**********************************************************/
 {
-    char *pAlign = "WORD";
-    char *pAlignSt = "PARA";
-    char *pUse = "";
+    const char *pAlign = "WORD";
+    const char *pAlignSt = "PARA";
+    const char *pUse = "";
 	char align[16];
     struct asym *sym;
     const char *pFmt;
diff --git a/symbols.c b/symbols.c
index 2a89151f..60c7e041 100644
--- a/symbols.c
+++ b/symbols.c
@@ -112,12 +112,15 @@ struct tmitem {
     struct asym **store;
 };
 
+static char STR_VERSION[] = { '1','0','0','0', 0 }; /* "1000" */
+
 /* table of predefined text macros */
 static const struct tmitem tmtab[] = {
     /* @Version contains the Masm compatible version */
     /* v2.06: value of @Version changed to 800 */
     //{"@Version",  "615", NULL },
-    {"@Version",  "1000", NULL },
+    //{"@Version",  "1000", NULL },
+    {"@Version",  STR_VERSION, NULL },
     {"@Date",     szDate, NULL },
     {"@Time",     szTime, NULL },
     {"@FileName", ModuleInfo.name, NULL },
@@ -125,7 +128,7 @@ static const struct tmitem tmtab[] = {
     /* v2.09: @CurSeg value is never set if no segment is ever opened.
      * this may have caused an access error if a listing was written.
      */
-    {"@CurSeg",   "", &symCurSeg }
+    {"@CurSeg",   STR_EMPTY, &symCurSeg }
 };
 
 struct eqitem {
@@ -248,7 +251,7 @@ struct asym *SymAlloc( const char *name )
         memcpy( sym->name, name, len );
         sym->name[len] = NULLC;
     } else
-        sym->name = "";
+        sym->name = STR_EMPTY;
     return( sym );
 }
 
diff --git a/tokenize.c b/tokenize.c
index 21a8aeae..aec7cd7a 100644
--- a/tokenize.c
+++ b/tokenize.c
@@ -77,6 +77,14 @@ extern char    *commentbuffer;
 #define tolower(c) ((c >= 'A' && c <= 'Z') ? c | 0x20 : c )
 #endif
 
+static char STR_DBL_COLON[]     = { ':',':', 0 };
+static char STR_COLON[]         = { ':', 0 };
+static char STR_POINTER[]       = { '-','>', 0 };
+static char STR_PERCENT[]       = { '%', 0 };
+static char STR_EQUALSGN[]      = { '=', 0 };
+static char STR_AMPERSAND[]     = { '&', 0 };
+static char STR_QUESTION_MARK[] = { '?', 0 };
+
 /* strings for token 0x28 - 0x2F */
 static const short stokstr1[] = {
     '(',')','*','+',',','-','.','/'};
@@ -596,10 +604,10 @@ static ret_code get_special_symbol( struct asm_tok *buf, struct line_status *p )
         if ( *p->input == ':' ) {
             p->input++;
             buf->token = T_DBL_COLON;
-            buf->string_ptr = "::";
+            buf->string_ptr = STR_DBL_COLON;
         } else {
             buf->token = T_COLON;
-            buf->string_ptr = ":";
+            buf->string_ptr = STR_COLON;
         }
         break;
 	case '-': 
@@ -607,7 +615,7 @@ static ret_code get_special_symbol( struct asm_tok *buf, struct line_status *p )
 		if (*p->input == '>') {
 			p->input++;
 			buf->token = T_POINTER;
-			buf->string_ptr = "->";
+			buf->string_ptr = STR_POINTER;
 		}
 		else {
 			p->input--;
@@ -634,7 +642,7 @@ static ret_code get_special_symbol( struct asm_tok *buf, struct line_status *p )
             return( EMPTY );
         }
         buf->token = T_PERCENT;
-        buf->string_ptr = "%";
+        buf->string_ptr = STR_PERCENT;
         break;
     case '(' : /* 0x28: T_OP_BRACKET operator - needs a matching ')' */
         /* v2.11: reset c-expression flag if a macro function call is detected */
@@ -696,7 +704,7 @@ static ret_code get_special_symbol( struct asm_tok *buf, struct line_status *p )
             buf->token = T_DIRECTIVE;
             buf->tokval = T_EQU;
             buf->dirtype = DRT_EQUALSGN; /* to make it differ from EQU directive */
-            buf->string_ptr = "=";
+            buf->string_ptr = STR_EQUALSGN;
             p->input++;
             break;
         }
@@ -734,7 +742,7 @@ static ret_code get_special_symbol( struct asm_tok *buf, struct line_status *p )
         if ( symbol == '&' ) {
             p->input++;
             buf->token = '&';
-            buf->string_ptr = "&";
+            buf->string_ptr = STR_AMPERSAND;
             break;
         }
         /* anything we don't recognise we will consider a string,
@@ -996,7 +1004,7 @@ static ret_code get_id( struct asm_tok *buf, struct line_status *p )
     if( size == 1 && *p->output == '?' ) {
         p->input = src;
         buf->token = T_QUESTION_MARK;
-        buf->string_ptr = "?";
+        buf->string_ptr = STR_QUESTION_MARK;
         return( NOT_ERROR );
     }
     index = FindResWord( p->output, size );
@@ -1474,7 +1482,7 @@ int Tokenize( char *line, unsigned int start, struct asm_tok tokenarray[], unsig
 skipline:
     tokenarray[p.index].token  = T_FINAL;
     tokenarray[p.index].bytval = p.flags3;
-    tokenarray[p.index].string_ptr = "";
+    tokenarray[p.index].string_ptr = STR_EMPTY;
     return( p.index );
 }
 
diff --git a/types.c b/types.c
index dfe9ad06..a3160880 100644
--- a/types.c
+++ b/types.c
@@ -45,6 +45,9 @@ static const char szRecord[] = "record";
 
 static const char szNonUnique[] = "NONUNIQUE";
 
+/* empty string (char *)"" */
+char STR_EMPTY[1] = { 0 };
+
 void TypesInit( void )
 /********************/
 {
@@ -204,7 +207,7 @@ ret_code StructDirective( int i, struct asm_tok tokenarray[] )
             name = tokenarray[i].string_ptr;
             i++;
         } else {
-            name = "";
+            name = STR_EMPTY;
         }
     } else {
         name = tokenarray[0].string_ptr;
@@ -404,7 +407,7 @@ ret_code CStructDirective(int i, struct asm_tok tokenarray[])
 			i++;
 		}
 		else {
-			name = "";
+			name = STR_EMPTY;
 		}
 	}
 	else {
@@ -619,7 +622,7 @@ ret_code RAWStructDirective(int i, struct asm_tok tokenarray[])
 			i++;
 		}
 		else {
-			name = "";
+			name = STR_EMPTY;
 		}
 	}
 	else {
@@ -843,7 +846,7 @@ ret_code COMStructDirective(int i, struct asm_tok tokenarray[])
 			i++;
 		}
 		else {
-			name = "";
+			name = STR_EMPTY;
 		}
 	}
 	else {
@@ -1118,7 +1121,7 @@ ret_code EndstructDirective( int i, struct asm_tok tokenarray[] )
         //sym->name = dir->sym.name;
         //sym->name_size = strlen( dir->sym.name );
         sym->total_size = dir->sym.total_size;
-        dir->sym.name = ""; /* the type becomes anonymous */
+        dir->sym.name = STR_EMPTY; /* the type becomes anonymous */
         dir->sym.name_size = 0;
     }
 
@@ -1242,7 +1245,7 @@ struct asym *CreateStructField( int loc, struct asm_tok tokenarray[], const char
              vartype->typekind == TYPE_UNION ) ) {
             CheckAnonymousStruct( (struct dsym *)vartype );
         }
-        name = "";
+        name = STR_EMPTY;
         len = 0;
     }
 
@@ -1301,7 +1304,7 @@ struct asym *CreateStructField( int loc, struct asm_tok tokenarray[], const char
         memcpy( f->sym.name, name, len );
         f->sym.name[len] = NULLC;
     } else
-        f->sym.name = "";
+        f->sym.name = STR_EMPTY;
     f->sym.state = SYM_STRUCT_FIELD;
     f->sym.list = ModuleInfo.cref;
     f->sym.isdefined = TRUE;

From 1b95cb75aa118f5af1b379e1d9f0eb152b0d7e0c Mon Sep 17 00:00:00 2001
From: darealshinji <djcj@gmx.de>
Date: Sat, 7 Dec 2024 15:21:06 +0100
Subject: [PATCH 11/11] typo

---
 symbols.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/symbols.c b/symbols.c
index 60c7e041..421813db 100644
--- a/symbols.c
+++ b/symbols.c
@@ -869,13 +869,13 @@ void SymSimd(struct dsym *sym)
 
   sym->e.structinfo->memberCount = memberCount;
   if (vtotal == 0x20 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) || 
-    (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))  
+    (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD || htype == MT_DWORD || htype == MT_QWORD)))
     sym->e.structinfo->stype = MM256;
   else if (vtotal == 0x10 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||
-    (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
+    (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD || htype == MT_DWORD || htype == MT_QWORD)))
     sym->e.structinfo->stype = MM128;
   else if (vtotal == 0x40 && sym->e.structinfo->isHomogenous == 1 && ((sym->sym.typekind == TYPE_UNION) ||
-    (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD | htype == MT_DWORD || htype == MT_QWORD)))
+    (htype == MT_REAL4 || htype == MT_REAL8 || htype == MT_BYTE || htype == MT_WORD || htype == MT_DWORD || htype == MT_QWORD)))
     sym->e.structinfo->stype = MM512;
 
   // Ensure unions of multiple MM128 or MM256 types default to a 4/8 member float arrangement.
